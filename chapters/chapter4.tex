\documentclass[../main.tex]{subfiles}

\begin{document}

\section{Exercise 4.1}

Code:

\begin{lstlisting}
;; left to right version
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let ((first (eval (first-operand exps) env)))
        (cons first
              (list-of-values (rest-operands exps) env)))))

;; right to left version
(define (list-of-value exps env)
  (if (no-operands? exps)
      '()
      (let ((rest (list-of-values (rest-operands exps) env)))
        (cons (eval (first-operand exps) env)
              rest))))
\end{lstlisting}

\section{Exercise 4.2}

\subsection{a.}

The evaluator will regard \lstinline{(define x 3)} as procedure
application instead of variable definition. Essentially this is
because there lacks a robust way of distinguish different types
of expressions.

\subsection{b.}

Feel sorry for you Louis, really. I understand your feeling.

Code:

\begin{lstlisting}
(define (application? exp) (tagged-list? exp 'call))
(define (operator exp) (cadr exp))
(define (operands exp) (cddr exp))
\end{lstlisting}

\section{Exercise 4.3}

Code:

\begin{lstlisting}
(define (eval exp env)
  ((get 'eval (type exp)) exp env))
(define type car)
(define content cdr)

;; sample evaluation rule
(let ((eval-if
       (lambda (exp env)
               (if (true? (eval (if-predicate exp) env))
                   (eval (if-consequent exp) env)
                   (eval (if-alternative exp) env)))))
  (put 'eval 'if eval-if))                
\end{lstlisting}

\section{Exercise 4.4}

\subsection{Syntax definition}

Code:

\begin{lstlisting}
(define (and? exp) (tagged-list? exp 'and))
(define and-clauses cdr)

(define (or? exp) (tagged-list? exp 'or))
(define or-clauses cdr)

(define no-clauses? null?)
(define first-clause car)
(define rest-clauses cdr)
\end{lstlisting}

\subsection{Special form evaluation}

Code:

\begin{lstlisting}
(define (eval-and exp env)
  (define (eval-and-clauses clauses)
    (cond ((no-clauses? clauses) #t)
          ((true? (eval (first-clause clauses) env))
           (eval-and-clauses (rest-clauses clauses)))
          (else #f)))
  (eval-and-clauses (and-clauses exp)))

(define (eval-or exp env)
  (define (eval-or-clauses clauses)
    (cond ((no-clauses? clauses #f))
          ((true? (eval (first-clause clauses) env)) #t)
          (else (eval (rest-clauses clauses env)))))
  (eval-or-clauses (or-clauses exp)))
\end{lstlisting}

\subsection{Derived form evaluation}

Code:

\begin{lstlisting}
;; transform AST-and to AST-if
(define (and-to-if exp)
  (define (expand-clauses clauses)
    (if (no-clauses? clauses)
        'true
        (make-if (first-clause clauses)
                 (expand-clauses (rest-clauses clauses))
                 'false)))
  (expand-clauses (and-clauses exp)))

;; transform AST-or to AST-if
(define (or-to-if exp)
  (define (expand-clauses clauses)
    (if (no-clauses? clauses)
        'false
        (make-if (first-clause clauses)
                 'true
                 (expand-clauses (rest-clauses clauses)))))
  (expand-clauses (or-clauses exp)))
\end{lstlisting}

\section{Exercise 4.5}

One thing noteworthy is that the recipient
procedure is invoked on the value of the expression
(result of evaluating it), not the expression itself.
The expression is only evaluated once, after which
its value is used for both branching and possibly
recipient. Thus the condition branch
\lstinline{(#test-exp => #recipient)} should be
transformed to the following expression:

\begin{lstlisting}
(let ((exp-value #test-exp))
  (if exp-value
      (#recipient exp-value)
      ;; other branches
))
\end{lstlisting}

This introduces the same problem as macros do. The local
variable \lstinline{exp-value} could introduce name conflict
with another variable named \lstinline{exp-value} in other branches,
therefore shadow the previous definition of that variable.
And, the variable binding of \lstinline{exp-value}
isn't supposed to leak into other branches and possibly
let expressions in other branches refer to it, which should've
caused an unbound variable error.

The problem seems inevitable for now. One way to tackle it is to use
the same technique as macros do to avoid name conflict. Another way
is to treat \lstinline{cond} expressions as a special form and
make the intermediate variable \lstinline{exp-value} only exist
at runtime (during the evaluation of the \lstinline{cond}
expression).

\section{Exercise 4.6}

Code:

\begin{lstlisting}
;; let expression format:
;; (let bindings body)
;;
;; bindings format:
;; (binding0 binding1 binding2 ...)
;;
;; binding format:
;; (var . exp)

(define (let? exp) (tagged-list? exp 'let))
(define let-bindings cadr)
(define let-body caddr)
(define no-bindings? null?)
(define first-binding car)
(define rest-bindings cdr)
(define binding-var car)
(define binding-exp cdr)

(define (let->combination let-exp)
  (let* ((bindings (let-bindings let-exp))
         (body (let-body let-exp))
         (parameters (map binding-var bindings))
         (arguments (map binding-exp bindings)))
    (cons (make-lambda parameters body)
          arguments)))
\end{lstlisting}

\section{Exercise 4.7}

Code:

\begin{lstlisting}
(define (let*->nested-lets let*-exp)
  (define (transform-bindings bindings)
    (if (no-bindings? bindings)
        (let*-body let*-exp)
        (make-let (list (first-binding bindings))
                  (transform-bindings (rest-bindings bindings)))))
  (transform-bindings (let*-bindings let*-exp)))
\end{lstlisting}

It is sufficient since the second call to \lstinline{eval} will
perform another dispatch to handle \lstinline{let} expression, where
the \lstinline{let} expression will be transformed to combination
and evaluated.

\section{Exercise 4.8}

We already know that a \lstinline{let} expression is equivalent
to function application. Named \lstinline{let} is no different, where
the function being applied can be recursive now. The expression
\lstinline{(let #var #bindings #body)} is equivalent to:

\begin{lstlisting}
(let ((#var (lambda (#parameters) #body)))
  (#var #arguments))
\end{lstlisting}

Thus the transformation can be implemented as follows:

\begin{lstlisting}
;; here I'll just leave out the dispatch and implement transformation
;; from named let to combination

(define (named-let->let named-let-exp)
  (let* ((var (named-let-var named-let-exp))
         (bindings (named-let-bindings named-let-exp))
         (body (named-let-body named-let-exp))
         (parameters (map binding-var bindings))
         (arguments (map binding-exp bindings)))
    (make-let (list (cons var
                          (make-lambda parameters
                                       body)))
              (cons var arguments))))

(define (named-let->combination named-let-exp)
  (let->combination (named-let->let named-let-exp)))
\end{lstlisting}

\section{Exercise 4.9}

Basically we're defining a syntactic sugar. Let's define a
\lstinline{while} construct. First the syntax:

\begin{lstlisting}
(while #condition #exp)
\end{lstlisting}

It's equivalent to:

\begin{lstlisting}
(if #condition
    (begin #exp
           (while #condition #exp))
    'ok)
\end{lstlisting}

It's quite noteworthy that it's a recursive definition. We
can actually define this as a macro (tested in Racket):

\begin{lstlisting}
(define-syntax-rule (while condition exp)
  (letrec ((loop
            (lambda ()
              (if condition
                  (begin exp
                         (loop))
                  'ok))))
    (loop)))
\end{lstlisting}

Some simple test:

\begin{lstlisting}
(let ((x 10))
  (while (> x 0)
         (begin (display x)
                (newline)
                (set! x (- x 1)))))
\end{lstlisting}

Result:

\begin{lstlisting}
10
9
8
7
6
5
4
3
2
1
'ok
\end{lstlisting}

\section{Exercise 4.10}

Modifying implementation of constructors and selectors will do.
Since they are the only interfaces across which \lstinline{eval}
and \lstinline{apply} access and manipulate the program, thest two
methods won't need any modification. The specific code is left as
an exercise to the readers ;)

\end{document}
