\documentclass[../main.tex]{subfiles}

\begin{document}

\section{Exercise 4.1}

Code:

\begin{lstlisting}
;; left to right version
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let ((first (eval (first-operand exps) env)))
        (cons first
              (list-of-values (rest-operands exps) env)))))

;; right to left version
(define (list-of-value exps env)
  (if (no-operands? exps)
      '()
      (let ((rest (list-of-values (rest-operands exps) env)))
        (cons (eval (first-operand exps) env)
              rest))))
\end{lstlisting}

\section{Exercise 4.2}

\subsection{a.}

The evaluator will regard \lstinline{(define x 3)} as procedure
application instead of variable definition. Essentially this is
because there lacks a robust way of distinguish different types
of expressions.

\subsection{b.}

Feel sorry for you Louis, really. I understand your feeling.

Code:

\begin{lstlisting}
(define (application? exp) (tagged-list? exp 'call))
(define (operator exp) (cadr exp))
(define (operands exp) (cddr exp))
\end{lstlisting}

\section{Exercise 4.3}

Code:

\begin{lstlisting}
(define (eval exp env)
  ((get 'eval (type exp)) exp env))
(define type car)
(define content cdr)

;; sample evaluation rule
(let ((eval-if
       (lambda (exp env)
               (if (true? (eval (if-predicate exp) env))
                   (eval (if-consequent exp) env)
                   (eval (if-alternative exp) env)))))
  (put 'eval 'if eval-if))                
\end{lstlisting}

\section{Exercise 4.4}

\subsection{Syntax definition}

Code:

\begin{lstlisting}
(define (and? exp) (tagged-list? exp 'and))
(define and-clauses cdr)

(define (or? exp) (tagged-list? exp 'or))
(define or-clauses cdr)

(define no-clauses? null?)
(define first-clause car)
(define rest-clauses cdr)
\end{lstlisting}

\subsection{Special form evaluation}

Code:

\begin{lstlisting}
(define (eval-and exp env)
  (define (eval-and-clauses clauses)
    (cond ((no-clauses? clauses) #t)
          ((true? (eval (first-clause clauses) env))
           (eval-and-clauses (rest-clauses clauses)))
          (else #f)))
  (eval-and-clauses (and-clauses exp)))

(define (eval-or exp env)
  (define (eval-or-clauses clauses)
    (cond ((no-clauses? clauses #f))
          ((true? (eval (first-clause clauses) env)) #t)
          (else (eval (rest-clauses clauses env)))))
  (eval-or-clauses (or-clauses exp)))
\end{lstlisting}

\subsection{Derived form evaluation}

Code:

\begin{lstlisting}
;; transform AST-and to AST-if
(define (and-to-if exp)
  (define (expand-clauses clauses)
    (if (no-clauses? clauses)
        'true
        (make-if (first-clause clauses)
                 (expand-clauses (rest-clauses clauses))
                 'false)))
  (expand-clauses (and-clauses exp)))

;; transform AST-or to AST-if
(define (or-to-if exp)
  (define (expand-clauses clauses)
    (if (no-clauses? clauses)
        'false
        (make-if (first-clause clauses)
                 'true
                 (expand-clauses (rest-clauses clauses)))))
  (expand-clauses (or-clauses exp)))
\end{lstlisting}

\section{Exercise 4.5}

One thing noteworthy is that the recipient
procedure is invoked on the value of the expression
(result of evaluating it), not the expression itself.
The expression is only evaluated once, after which
its value is used for both branching and possibly
recipient. Thus the condition branch
\lstinline{(#test-exp => #recipient)} should be
transformed to the following expression:

\begin{lstlisting}
(let ((exp-value #test-exp))
  (if exp-value
      (#recipient exp-value)
      ;; other branches
))
\end{lstlisting}

This introduces the same problem as macros do. The local
variable \lstinline{exp-value} could introduce name conflict
with another variable named \lstinline{exp-value} in other branches,
therefore shadow the previous definition of that variable.
And, the variable binding of \lstinline{exp-value}
isn't supposed to leak into other branches and possibly
let expressions in other branches refer to it, which should've
caused an unbound variable error.

The problem seems inevitable for now. One way to tackle it is to use
the same technique as macros do to avoid name conflict. Another way
is to treat \lstinline{cond} expressions as a special form and
make the intermediate variable \lstinline{exp-value} only exist
at runtime (during the evaluation of the \lstinline{cond}
expression).

\section{Exercise 4.6}

Code:

\begin{lstlisting}
;; let expression format:
;; (let bindings body)
;;
;; bindings format:
;; (binding0 binding1 binding2 ...)
;;
;; binding format:
;; (var . exp)

(define (let? exp) (tagged-list? exp 'let))
(define let-bindings cadr)
(define let-body caddr)
(define no-bindings? null?)
(define first-binding car)
(define rest-bindings cdr)
(define binding-var car)
(define binding-exp cdr)

(define (let->combination let-exp)
  (let* ((bindings (let-bindings let-exp))
         (body (let-body let-exp))
         (parameters (map binding-var bindings))
         (arguments (map binding-exp bindings)))
    (cons (make-lambda parameters body)
          arguments)))
\end{lstlisting}

\section{Exercise 4.7}

Code:

\begin{lstlisting}
(define (let*->nested-lets let*-exp)
  (define (transform-bindings bindings)
    (if (no-bindings? bindings)
        (let*-body let*-exp)
        (make-let (list (first-binding bindings))
                  (transform-bindings (rest-bindings bindings)))))
  (transform-bindings (let*-bindings let*-exp)))
\end{lstlisting}

It is sufficient since the second call to \lstinline{eval} will
perform another dispatch to handle \lstinline{let} expression, where
the \lstinline{let} expression will be transformed to combination
and evaluated.

\section{Exercise 4.8}

We already know that a \lstinline{let} expression is equivalent
to function application. Named \lstinline{let} is no different, where
the function being applied can be recursive now. The expression
\lstinline{(let #var #bindings #body)} is equivalent to:

\begin{lstlisting}
(let ((#var (lambda (#parameters) #body)))
  (#var #arguments))
\end{lstlisting}

Thus the transformation can be implemented as follows:

\begin{lstlisting}
;; here I'll just leave out the dispatch and implement transformation
;; from named let to combination

(define (named-let->let named-let-exp)
  (let* ((var (named-let-var named-let-exp))
         (bindings (named-let-bindings named-let-exp))
         (body (named-let-body named-let-exp))
         (parameters (map binding-var bindings))
         (arguments (map binding-exp bindings)))
    (make-let (list (cons var
                          (make-lambda parameters
                                       body)))
              (cons var arguments))))

(define (named-let->combination named-let-exp)
  (let->combination (named-let->let named-let-exp)))
\end{lstlisting}

\section{Exercise 4.9}

Basically we're defining a syntactic sugar. Let's define a
\lstinline{while} construct. First the syntax:

\begin{lstlisting}
(while #condition #exp)
\end{lstlisting}

It's equivalent to:

\begin{lstlisting}
(if #condition
    (begin #exp
           (while #condition #exp))
    'ok)
\end{lstlisting}

It's quite noteworthy that it's a recursive definition. We
can actually define this as a macro (tested in Racket):

\begin{lstlisting}
(define-syntax-rule (while condition exp)
  (letrec ((loop
            (lambda ()
              (if condition
                  (begin exp
                         (loop))
                  'ok))))
    (loop)))
\end{lstlisting}

Some simple test:

\begin{lstlisting}
(let ((x 10))
  (while (> x 0)
         (begin (display x)
                (newline)
                (set! x (- x 1)))))
\end{lstlisting}

Result:

\begin{lstlisting}
10
9
8
7
6
5
4
3
2
1
'ok
\end{lstlisting}

\section{Exercise 4.10}

Modifying implementation of constructors and selectors will do.
Since they are the only interfaces across which \lstinline{eval}
and \lstinline{apply} access and manipulate the program, thest two
methods won't need any modification. The specific code is left as
an exercise to the readers ;)

\section{Exercise 4.11}

Code:

\begin{lstlisting}
(define (make-frame variables values)
  (list (map cons variables values)))

(define (frame-variables frame)
  (map car (car frame)))

(define (frame-values frame)
  (map cdr (car frame)))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons (cons var val) (car frame))))
\end{lstlisting}

\section{Exercise 4.12}

The lookup procedure is as follows:

\begin{itemize}
\item traverse all frames
\item for every frame, traverse its bindings
\item if binding matched, return value of it
\end{itemize}

The set procedure is as follows:

\begin{itemize}
\item traverse all frames
\item for every frame, traverse its bindings
\item if binding matched, set value of it
\end{itemize}

The define procedure is as follows:

\begin{itemize}
\item for the first frame, traverse its bindings
\item if binding matched, set value of it
\item if none matched, insert new binding
\end{itemize}

These operations can be extracted from above:

\begin{itemize}
\item frame traversal
\item binding traversal
\end{itemize}

Code:

\begin{lstlisting}
(define (frame-traversal env operation)
  (if (eq? env the-empty-environment)
      (error "nothing found during frame traversal")
      (let ((first-frame-result (operation (first-frame env))))
        (if first-frame-result
            first-frame-result
            (frame-traversal (enclosing-environment env)
                             operation)))))

;; binding defined as list of pairs
(define (binding-traversal frame operation)
  (define (helper bindings)
    (if (null? bindings)
        #f
        (let ((first-binding-result (operation (car bindings))))
          (if first-binding-result
              first-binding-result
              (helper (cdr bindings))))))
  (helper (car frame)))

(define (lookup-variable-value var env)
  (frame-traversal env
                   (lambda (frame)
                     (binding-traversal frame
                                        (lambda (binding)
                                          (if (eq? var (car binding))
                                              (cdr binding)
                                              #f))))))

(define (set-variable-value! var val env)
  (frame-traversal env
                   (lambda (frame)
                     (binding-traversal frame
                                        (lambda (binding)
                                          (if (eq? var
                                                   (car binding))
                                              (begin (set-cdr! binding
                                                               val)
                                                     'ok)
                                              #f))))))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (if (binding-traversal frame
                           (lambda (binding)
                             (if (eq? var
                                      (car binding))
                                 (begin (set-cdr! binding val)
                                        'ok)
                                 #f)))
        'ok
        (add-binding-to-frame! var val frame))))
\end{lstlisting}

\section{Exercise 4.13}

There are several cases to consider:

\begin{enumerate}
\item the binding is only in the first frame
\item the binding is only in the enclosing environment
\item the binding is in both the first frame and the enclosing environment
\item the binding is in neither the first frame nor the enclosing
environment
\end{enumerate}

Except for the fourth case where nothing can be done, the other three
need careful consideration.

But why does anyone want to get rid of bindings?

It turns out that this could be useful for imperative style programming,
where there could be something like:

\begin{lstlisting}
(define (square-sum a b)
  (define sum 0)
  (define term-squared 0)
  (set! term-squared (* a a))
  (set! sum (+ sum term-squared))
  (set! term-squared (* b b))
  (set! sum (+ sum term-squared))
  (make-unbound! term-squared)
  ; get rid of this binding
  ; so that some other careless guy
  ; can never carelessly refer to it later
  sum)
\end{lstlisting}

This is stupid. What is supposed to be done easily and safely with
scope now requires programmers to manually intervene. While in Python
this does make some sense, where they can't even implement the scope
of loops correctly:

\begin{lstlisting}[language=Python]
for i in range(10):
  print(i)

# loops don't create new scope
# so you can still access it
# amazing
print(i)

# get rid of it
del i
\end{lstlisting}

\section{Exercise 4.14}

The system version of \lstinline{map} expects the procedure to be
defined in the environment of the evaluator, not that of user program.
This is confusing since we're implementing a Scheme evaluator using
Scheme itself. Considering the situation where we're implementing a Python
interpreter using Scheme helps to understand the problem. Given the
procedure argument (as a symbol), Louis's \lstinline{map} will look for
a Scheme procedure in the environment of the interpreter instead of a
Python procedure in the environment of the user program.

\section{Exercise 4.15}

If evaluating \lstinline{(try try)} halts, it indicates that evaluating
\lstinline{(halts? try try)} returns \lstinline{#f}. Thus, from the
definition of \lstinline{halts?} we know that \lstinline{try} doesn't
halt on \lstinline{try}, which leads to a contradiction with the fact
that \lstinline{(try try)} halts at the very beginning.

If evaluating \lstinline{(try try)} runs forever, it indicates that
evaluating \lstinline{(halts? try try)} returns \lstinline{#t}, from
which we know that \lstinline{try} does halt on \lstinline{try}.
Contradiction again. Any possible outcome of evaluating
\lstinline{(try try)} violates the intended behaviour of
\lstinline{halts?}.

\section{Exercise 4.16}

\subsection{a.}

Code:

\begin{lstlisting}
(define (lookup-variable-value var env)
  (frame-traversal
    env
    (lambda (frame)
            (binding-traversal
              frame
              (lambda (binding)
                      (if (eq? var
                               (car binding))
                          (if (eq? (cdr binding)
                                   '*unassigned)
                              (error "Unsigned variable"
                                     var)
                              (cdr binding))
                          #f))))))
\end{lstlisting}

\subsection{b.}

Code:

\begin{lstlisting}
;; (lambda (...) (define u #e1) (define v #e2) ...)
;; to
;; (lambda (...) (let ((u ...) (v ...)) (set! u ...) (set! v ...) ...)

(define (scan-out-defines exp)
  (define (extract-defines exp)
    (cond ((definition? exp)
           (list (cons (definition-variable exp)
                       (definition-value exp))))
          ((begin? exp)
           (let ((exps (begin-actions exp)))
             (foldr append
                    '()
                    (map extract-defines
                         exps))))
          (else '())))
  (define (remove-defines exp)
    (if (begin? exp)
        (make-begin (map remove-defines
                         (filter (lambda (exp)
                                   (not (definition? exp)))
                                 (begin-actions exp))))
        exp))
  (define (create-empty-bindings variables)
    (map (lambda (var) (cons (var '*unassigned*)))
         variables))
  (define (insert-assignments definitions exp)
    (define (insert-helper definitions exp)
      (if (null? definitions)
          (list exp)
          (cons (make-assignment (caar definitions)
                                 (cdar definitions))
                (insert-helper (cdr definitions)
                               exp))))
    (make-begin (insert-helper definitions exp)))
  (let ((local-definitions (extract-defines exp)))
    (if (null? local-definitions)
        exp
        (let ((variables (map car
                              local-definitions)))
          (make-let (create-empty-bindings variables)
                    (insert-assignments local-definitions exp))))))
\end{lstlisting}

\subsection{c.}

Installing in \lstinline{make-procedure} is better, ensuring \lstinline{scan-out-defines} is only invoked once.

\section{Exercise 4.17}

Sequentially interpreted environment:

\begin{lstlisting}
  environment
  where lambda
  got evaluated
        ^
        |
+---------------------+
| (argument bindings) |
| u: value of e1      | env0
| v: value of e2      |
+---------------------+
\end{lstlisting}

Scanned out environment:

\begin{lstlisting}
  environment
  where lambda
  got evaluated
        ^
        |
+---------------------+
| (argument bindings) | env1
+---------------------+
        ^
        |
+----------------+
| u: value of e1 | env2
| v: value of e2 |
+----------------+
\end{lstlisting}

The extra frame is created by the \lstinline{let} expression.

The difference in environment can never make a difference in the behaviour of a correct program, since the evaluation of $e3$ can access the exact same set of bindings (\lstinline{u}, \lstinline{v}, arguments and those in enclosing environment) whether it's evaluated in \lstinline{env0} or \lstinline{env2}.

To implement the simultaneous scope rule for internal definitions without any extra frames, one can make the evaluator evaluate a block structure in two passes, in the first of which the evaluator evaluates every internal definition before evaluating any other expressions.

\section{Exercise 4.18}

Expanding the procedure produces code like this:

\begin{lstlisting}
(define solve
  (lambda (f y0 dt)
    (let ((y '*unassigned*)
          (dy '*unassigned*))
      (let ((a (integral (delay dy) y0 dt))
            (b (stream-map f y)))
        (set! u a)
        (set! v b))
      y)))
\end{lstlisting}

This won't work. When evaluating the inner \lstinline{let} expression, \lstinline{(stream-map f y)} is eagerly evaluated while \lstinline{y} is bound to nothing.

If expanded as shown in the text:

\begin{lstlisting}
(define solve
  (lambda (f y0 dt)
    (let ((y '*unassigned*)
          (dy '*unassigned*))
      (set! y (integral (delay dy) y0 dt))
      (set! dy (stream-map f y))
      y)))
\end{lstlisting}

The second version works correctly, as \lstinline{y} is already assigned with valid value before \lstinline{(stream-map f y)} is evaluated.

To accommodate the first approach to this problem, delayed evaluation is needed (i.e. \lstinline{y} must not be eagerly evaluated).









\end{document}
