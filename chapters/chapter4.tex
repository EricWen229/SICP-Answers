\documentclass[../main.tex]{subfiles}

\begin{document}

\section{Exercise 4.1}

Code:

\begin{lstlisting}
;; left to right version
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let ((first (eval (first-operand exps) env)))
        (cons first
              (list-of-values (rest-operands exps) env)))))

;; right to left version
(define (list-of-value exps env)
  (if (no-operands? exps)
      '()
      (let ((rest (list-of-values (rest-operands exps) env)))
        (cons (eval (first-operand exps) env)
              rest))))
\end{lstlisting}

\section{Exercise 4.2}

\subsection{a.}

The evaluator will regard \lstinline{(define x 3)} as procedure
application instead of variable definition. Essentially this is
because there lacks a robust way of distinguish different types
of expressions.

\subsection{b.}

Feel sorry for you Louis, really. I understand your feeling.

Code:

\begin{lstlisting}
(define (application? exp) (tagged-list? exp 'call))
(define (operator exp) (cadr exp))
(define (operands exp) (cddr exp))
\end{lstlisting}

\section{Exercise 4.3}

Code:

\begin{lstlisting}
(define (eval exp env)
  ((get 'eval (type exp)) exp env))
(define type car)
(define content cdr)

;; sample evaluation rule
(let ((eval-if
       (lambda (exp env)
               (if (true? (eval (if-predicate exp) env))
                   (eval (if-consequent exp) env)
                   (eval (if-alternative exp) env)))))
  (put 'eval 'if eval-if))                
\end{lstlisting}

\section{Exercise 4.4}

\subsection{Syntax definition}

Code:

\begin{lstlisting}
(define (and? exp) (tagged-list? exp 'and))
(define and-clauses cdr)

(define (or? exp) (tagged-list? exp 'or))
(define or-clauses cdr)

(define no-clauses? null?)
(define first-clause car)
(define rest-clauses cdr)
\end{lstlisting}

\subsection{Special form evaluation}

Code:

\begin{lstlisting}
(define (eval-and exp env)
  (define (eval-and-clauses clauses)
    (cond ((no-clauses? clauses) #t)
          ((true? (eval (first-clause clauses) env))
           (eval-and-clauses (rest-clauses clauses)))
          (else #f)))
  (eval-and-clauses (and-clauses exp)))

(define (eval-or exp env)
  (define (eval-or-clauses clauses)
    (cond ((no-clauses? clauses #f))
          ((true? (eval (first-clause clauses) env)) #t)
          (else (eval (rest-clauses clauses env)))))
  (eval-or-clauses (or-clauses exp)))
\end{lstlisting}

\subsection{Derived form evaluation}

Code:

\begin{lstlisting}
;; transform AST-and to AST-if
(define (and-to-if exp)
  (define (expand-clauses clauses)
    (if (no-clauses? clauses)
        'true
        (make-if (first-clause clauses)
                 (expand-clauses (rest-clauses clauses))
                 'false)))
  (expand-clauses (and-clauses exp)))

;; transform AST-or to AST-if
(define (or-to-if exp)
  (define (expand-clauses clauses)
    (if (no-clauses? clauses)
        'false
        (make-if (first-clause clauses)
                 'true
                 (expand-clauses (rest-clauses clauses)))))
  (expand-clauses (or-clauses exp)))
\end{lstlisting}

\section{Exercise 4.5}

One thing noteworthy is that the recipient
procedure is invoked on the value of the expression
(result of evaluating it), not the expression itself.
The expression is only evaluated once, after which
its value is used for both branching and possibly
recipient. Thus the condition branch
\lstinline{(#test-exp => #recipient)} should be
transformed to the following expression:

\begin{lstlisting}
(let ((exp-value #test-exp))
  (if exp-value
      (#recipient exp-value)
      ;; other branches
))
\end{lstlisting}

This introduces the same problem as macros do. The local
variable \lstinline{exp-value} could introduce name conflict
with another variable named \lstinline{exp-value} in other branches,
therefore shadow the previous definition of that variable.
And, the variable binding of \lstinline{exp-value}
isn't supposed to leak into other branches and possibly
let expressions in other branches refer to it, which should've
caused an unbound variable error.

The problem seems inevitable for now. One way to tackle it is to use
the same technique as macros do to avoid name conflict. Another way
is to treat \lstinline{cond} expressions as a special form and
make the intermediate variable \lstinline{exp-value} only exist
at runtime (during the evaluation of the \lstinline{cond}
expression).

\section{Exercise 4.6}

Code:

\begin{lstlisting}
;; let expression format:
;; (let bindings body)
;;
;; bindings format:
;; (binding0 binding1 binding2 ...)
;;
;; binding format:
;; (var . exp)

(define (let? exp) (tagged-list? exp 'let))
(define let-bindings cadr)
(define let-body caddr)
(define no-bindings? null?)
(define first-binding car)
(define rest-bindings cdr)
(define binding-var car)
(define binding-exp cdr)

(define (let->combination let-exp)
  (let* ((bindings (let-bindings let-exp))
         (body (let-body let-exp))
         (parameters (map binding-var bindings))
         (arguments (map binding-exp bindings)))
    (cons (make-lambda parameters body)
          arguments)))
\end{lstlisting}

\section{Exercise 4.7}

Code:

\begin{lstlisting}
(define (let*->nested-lets let*-exp)
  (define (transform-bindings bindings)
    (if (no-bindings? bindings)
        (let*-body let*-exp)
        (make-let (list (first-binding bindings))
                  (transform-bindings (rest-bindings bindings)))))
  (transform-bindings (let*-bindings let*-exp)))
\end{lstlisting}

It is sufficient since the second call to \lstinline{eval} will
perform another dispatch to handle \lstinline{let} expression, where
the \lstinline{let} expression will be transformed to combination
and evaluated.

\section{Exercise 4.8}

We already know that a \lstinline{let} expression is equivalent
to function application. Named \lstinline{let} is no different, where
the function being applied can be recursive now. The expression
\lstinline{(let #var #bindings #body)} is equivalent to:

\begin{lstlisting}
(let ((#var (lambda (#parameters) #body)))
  (#var #arguments))
\end{lstlisting}

Thus the transformation can be implemented as follows:

\begin{lstlisting}
;; here I'll just leave out the dispatch and implement transformation
;; from named let to combination

(define (named-let->let named-let-exp)
  (let* ((var (named-let-var named-let-exp))
         (bindings (named-let-bindings named-let-exp))
         (body (named-let-body named-let-exp))
         (parameters (map binding-var bindings))
         (arguments (map binding-exp bindings)))
    (make-let (list (cons var
                          (make-lambda parameters
                                       body)))
              (cons var arguments))))

(define (named-let->combination named-let-exp)
  (let->combination (named-let->let named-let-exp)))
\end{lstlisting}

\section{Exercise 4.9}

Basically we're defining a syntactic sugar. Let's define a
\lstinline{while} construct. First the syntax:

\begin{lstlisting}
(while #condition #exp)
\end{lstlisting}

It's equivalent to:

\begin{lstlisting}
(if #condition
    (begin #exp
           (while #condition #exp))
    'ok)
\end{lstlisting}

It's quite noteworthy that it's a recursive definition. We
can actually define this as a macro (tested in Racket):

\begin{lstlisting}
(define-syntax-rule (while condition exp)
  (letrec ((loop
            (lambda ()
              (if condition
                  (begin exp
                         (loop))
                  'ok))))
    (loop)))
\end{lstlisting}

Some simple test:

\begin{lstlisting}
(let ((x 10))
  (while (> x 0)
         (begin (display x)
                (newline)
                (set! x (- x 1)))))
\end{lstlisting}

Result:

\begin{lstlisting}
10
9
8
7
6
5
4
3
2
1
'ok
\end{lstlisting}

\section{Exercise 4.10}

Modifying implementation of constructors and selectors will do.
Since they are the only interfaces across which \lstinline{eval}
and \lstinline{apply} access and manipulate the program, thest two
methods won't need any modification. The specific code is left as
an exercise to the readers ;)

\section{Exercise 4.11}

Code:

\begin{lstlisting}
(define (make-frame variables values)
  (list (map cons variables values)))

(define (frame-variables frame)
  (map car (car frame)))

(define (frame-values frame)
  (map cdr (car frame)))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons (cons var val) (car frame))))
\end{lstlisting}

\section{Exercise 4.12}

The lookup procedure is as follows:

\begin{itemize}
\item traverse all frames
\item for every frame, traverse its bindings
\item if binding matched, return value of it
\end{itemize}

The set procedure is as follows:

\begin{itemize}
\item traverse all frames
\item for every frame, traverse its bindings
\item if binding matched, set value of it
\end{itemize}

The define procedure is as follows:

\begin{itemize}
\item for the first frame, traverse its bindings
\item if binding matched, set value of it
\item if none matched, insert new binding
\end{itemize}

These operations can be extracted from above:

\begin{itemize}
\item frame traversal
\item binding traversal
\end{itemize}

Code:

\begin{lstlisting}
(define (frame-traversal env operation)
  (if (eq? env the-empty-environment)
      (error "nothing found during frame traversal")
      (let ((first-frame-result (operation (first-frame env))))
        (if first-frame-result
            first-frame-result
            (frame-traversal (enclosing-environment env)
                             operation)))))

;; binding defined as list of pairs
(define (binding-traversal frame operation)
  (define (helper bindings)
    (if (null? bindings)
        #f
        (let ((first-binding-result (operation (car bindings))))
          (if first-binding-result
              first-binding-result
              (helper (cdr bindings))))))
  (helper (car frame)))

(define (lookup-variable-value var env)
  (frame-traversal
    env
    (lambda (frame)
      (binding-traversal
        frame
        (lambda (binding)
          (if (eq? var (car binding))
              (cdr binding)
              #f))))))

(define (set-variable-value! var val env)
  (frame-traversal
    env
    (lambda (frame)
      (binding-traversal
        frame
        (lambda (binding)
          (if (eq? var (car binding))
              (begin (set-cdr! binding val)
                     'ok)
              #f))))))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (if (binding-traversal frame
                           (lambda (binding)
                             (if (eq? var
                                      (car binding))
                                 (begin (set-cdr! binding val)
                                        'ok)
                                 #f)))
        'ok
        (add-binding-to-frame! var val frame))))
\end{lstlisting}

\section{Exercise 4.13}

There are several cases to consider:

\begin{enumerate}
\item the binding is only in the first frame
\item the binding is only in the enclosing environment
\item the binding is in both the first frame and the enclosing environment
\item the binding is in neither the first frame nor the enclosing
environment
\end{enumerate}

Except for the fourth case where nothing can be done, the other three
need careful consideration.

But why does anyone want to get rid of bindings?

It turns out that this could be useful for imperative style programming,
where there could be something like:

\begin{lstlisting}
(define (square-sum a b)
  (define sum 0)
  (define term-squared 0)
  (set! term-squared (* a a))
  (set! sum (+ sum term-squared))
  (set! term-squared (* b b))
  (set! sum (+ sum term-squared))
  (make-unbound! term-squared)
  ; get rid of this binding
  ; so that some other careless guy
  ; can never carelessly refer to it later
  sum)
\end{lstlisting}

This is stupid. What is supposed to be done easily and safely with
scope now requires programmers to manually intervene. While in Python
this does make some sense, where they can't even implement the scope
of loops correctly:

\begin{lstlisting}[language=Python]
for i in range(10):
  print(i)

# loops don't create new scope
# so you can still access it
# amazing
print(i)

# get rid of it
del i
\end{lstlisting}

\section{Exercise 4.14}

The system version of \lstinline{map} expects the procedure to be
defined in the environment of the evaluator, not that of user program.
This is confusing since we're implementing a Scheme evaluator using
Scheme itself. Considering the situation where we're implementing a Python
interpreter using Scheme helps to understand the problem. Given the
procedure argument (as a symbol), Louis's \lstinline{map} will look for
a Scheme procedure in the environment of the interpreter instead of a
Python procedure in the environment of the user program.

\section{Exercise 4.15}

If evaluating \lstinline{(try try)} halts, it indicates that evaluating
\lstinline{(halts? try try)} returns \lstinline{#f}. Thus, from the
definition of \lstinline{halts?} we know that \lstinline{try} doesn't
halt on \lstinline{try}, which leads to a contradiction with the fact
that \lstinline{(try try)} halts at the very beginning.

If evaluating \lstinline{(try try)} runs forever, it indicates that
evaluating \lstinline{(halts? try try)} returns \lstinline{#t}, from
which we know that \lstinline{try} does halt on \lstinline{try}.
Contradiction again. Any possible outcome of evaluating
\lstinline{(try try)} violates the intended behaviour of
\lstinline{halts?}.

\section{Exercise 4.16}

\subsection{a.}

Code:

\begin{lstlisting}
(define (lookup-variable-value var env)
  (frame-traversal
    env
    (lambda (frame)
            (binding-traversal
              frame
              (lambda (binding)
                      (if (eq? var
                               (car binding))
                          (if (eq? (cdr binding)
                                   '*unassigned)
                              (error "Unsigned variable"
                                     var)
                              (cdr binding))
                          #f))))))
\end{lstlisting}

\subsection{b.}

Code:

\begin{lstlisting}
;; (lambda (...) (define u #e1) (define v #e2) ...)
;; to
;; (lambda (...) (let ((u ...) (v ...)) (set! u ...) (set! v ...) ...)

(define (scan-out-defines exp)
  (define (extract-defines exp)
    (cond ((definition? exp)
           (list (cons (definition-variable exp)
                       (definition-value exp))))
          ((begin? exp)
           (let ((exps (begin-actions exp)))
             (foldr append
                    '()
                    (map extract-defines
                         exps))))
          (else '())))
  (define (remove-defines exp)
    (if (begin? exp)
        (make-begin (map remove-defines
                         (filter (lambda (exp)
                                   (not (definition? exp)))
                                 (begin-actions exp))))
        exp))
  (define (create-empty-bindings variables)
    (map (lambda (var) (cons (var '*unassigned*)))
         variables))
  (define (insert-assignments definitions exp)
    (define (insert-helper definitions exp)
      (if (null? definitions)
          (list exp)
          (cons (make-assignment (caar definitions)
                                 (cdar definitions))
                (insert-helper (cdr definitions)
                               exp))))
    (make-begin (insert-helper definitions exp)))
  (let ((local-definitions (extract-defines exp)))
    (if (null? local-definitions)
        exp
        (let ((variables (map car
                              local-definitions)))
          (make-let (create-empty-bindings variables)
                    (insert-assignments local-definitions exp))))))
\end{lstlisting}

\subsection{c.}

Installing in \lstinline{make-procedure} is better, ensuring \lstinline{scan-out-defines} is only invoked once.

\section{Exercise 4.17}

Sequentially interpreted environment:

\begin{lstlisting}
  environment
  where lambda
  got evaluated
        ^
        |
+---------------------+
| (argument bindings) |
| u: value of e1      | env0
| v: value of e2      |
+---------------------+
\end{lstlisting}

Scanned out environment:

\begin{lstlisting}
  environment
  where lambda
  got evaluated
        ^
        |
+---------------------+
| (argument bindings) | env1
+---------------------+
        ^
        |
+----------------+
| u: value of e1 | env2
| v: value of e2 |
+----------------+
\end{lstlisting}

The extra frame is created by the \lstinline{let} expression.

The difference in environment can never make a difference in the behaviour of a correct program, since the evaluation of $e3$ can access the exact same set of bindings (\lstinline{u}, \lstinline{v}, arguments and those in enclosing environment) whether it's evaluated in \lstinline{env0} or \lstinline{env2}.

To implement the simultaneous scope rule for internal definitions without any extra frames, one can make the evaluator evaluate a block structure in two passes, in the first of which the evaluator evaluates every internal definition before evaluating any other expressions. Also one
can perform a transform on the AST to move all internal definitions to block structures' beginning.

\section{Exercise 4.18}

Expanding the procedure produces code as following:

\begin{lstlisting}
(define solve
  (lambda (f y0 dt)
    (let ((y '*unassigned*)
          (dy '*unassigned*))
      (let ((a (integral (delay dy) y0 dt))
            (b (stream-map f y)))
        (set! u a)
        (set! v b))
      y)))
\end{lstlisting}

This won't work. When evaluating the inner \lstinline{let} expression, \lstinline{(stream-map f y)} is eagerly evaluated while \lstinline{y} is bound to nothing.

If expanded as shown in the text:

\begin{lstlisting}
(define solve
  (lambda (f y0 dt)
    (let ((y '*unassigned*)
          (dy '*unassigned*))
      (set! y (integral (delay dy) y0 dt))
      (set! dy (stream-map f y))
      y)))
\end{lstlisting}

The second version works correctly, as \lstinline{y} is already assigned with valid value before \lstinline{(stream-map f y)} is evaluated.

To accommodate the first approach to this problem, delayed evaluation is needed (i.e. \lstinline{y} must not be eagerly evaluated).

\section{Exercise 4.19}

Now there are three opinions on the table:

\begin{itemize}
\item Ben: binding created and variable assigned after definition expression is evaluated
\item Alyssa: binding created when enter scope, but variable assigned after definition expression is evaluted
\item Eva: binding created and variable assigned when enter scope
\end{itemize}

Ben's suggestion appears quite "dynamic" to me. This is pretty straightforward and easy to implement, as the semantic here corresponds well to the evaluation process. But what makes it much less appealing is that it requires knowing the entire history to determine its current state, which would make the program way harder to reason about.
The most common intention behind defining a local variable possibly is to shadow any other outer variables, where such semantic would be quite counterintuitive.

Eva's suggestion, on the other hand, looks far more "lexical". And this is the most graceful one as I see it. The problem, however, arises from the reality. Firstly we have the efficiency issue, which is very little likely to be solvable. Also, it may seem confusing when the local variables are assigned at the very beginning, as if it happens before definition expressions are evaluated. Instead of the entire history, now it requires knowing its entire scope to determine its current state.

I personally favor Alyssa's suggestion most. Externally, the definitions are shadowed by internal definitions, allowing the programmer to think fully "locally". Internally, the definitions are processed in a quite "dynamic" way, letting the programmer to track internal definitions in a quite nature and straightforward way.

Now, before implementing the semantic as Eva suggests, notice that moving internal definitions to the beginning is no longer adequate. The order also matters, as shown in the example. \lstinline{a} should be already holding the value 5 before \lstinline{(+ a x)} is evaluated.

If there is a valid order, say, we can process definitions once at a time in some order, where each definition being processed doesn't need any other definitions that aren't processed yet, then we can use topological sort on dependency graph of definitions to discover such an order and rearrange internal definitions.

What if there's no valid orders? Take this expression for example:

\begin{lstlisting}
(define (some-function x)
  (define foo (+ x bar))
  (define bar (* x foo))
  (+ foo bar))
\end{lstlisting}

There's no way we can devise a valid semantic for this. What's worse is that such situation could be much harder to detect in real world scenarios, as the cycle could get much larger. Of course, we can run cycle detection on the dependency graph of definitions before performing topological sort, but now the whole process is going to be really complex and inefficient.

\section{Exercise 4.20}

\subsection{a.}

Code:

\begin{lstlisting}
;; transform
;; (letrec ((v0 e0) (v1 e1) ... (vn en)) body)
;; to
;; (let ((v0 'unassigned)
;;       (v1 'unassigned)
;;       ...
;;       (vn 'unassigned))
;;   (set! v0 e0)
;;   (set! v1 e1)
;;   ...
;;   (set! vn en)
;;   body)

;; definition of letrec
;; format: (letrec bindings body)
(define (letrec? exp) (tagged-list? exp 'letrec))
(define letrec-bindings cdar)
(define letrec-body cddar)
(define no-bindings? null?)
(define first-binding car)
(define rest-binding cdr)
(define binding-var car)
(define binding-exp cdr)

(define (letrec->let exp)
  (let ((bindings (letrec-bindings exp))
        (body (let-rec-body exp)))
    (make-let (create-empty-bindings (map binding-var
                                          bindings))
              (insert-assignments bindings body))))
\end{lstlisting}

\subsection{b.}

Environment with \lstinline{letrec}:

\begin{lstlisting}
+------+
| f#0  |
| ---- |
| x: 5 |
+------+
    ^
    |
+---------------------------------------------+
| letrec#0                                    |
| ------------------------------------------- |
| even?: (lambda (n) (...odd?...)) @ letrec#0 |
| odd?: (lambda (n) (...even?...)) @ letrec#0 |
+---------------------------------------------+
\end{lstlisting}

Notice that the lambda expressions of \lstinline{even?} and \lstinline{odd?} are both evaluated in the frame \lstinline{letrec#0}, thus their environments are both \lstinline{letrec#0}. When any of the procedures, like \lstinline{even?}, get invoked, the body will be evaluated in a new frame whose enclosing environment points to \lstinline{letrec#0}. Therefore, when it looks for \lstinline{odd?} in the environment, it'll find the binding in frame \lstinline{letrec#0}

Environment with \lstinline{let}:

\begin{lstlisting}
+------+
| f#0  |
| ---- |
| x: 5 |
+------+
    ^
    |
+----------------------------------------+
| let#0                                  |
| -------------------------------------- |
| even?: (lambda (n) (...odd?...)) @ f#0 |
| odd?: (lambda (n) (...even?...)) @ f#0 |
+----------------------------------------+
\end{lstlisting}

Notice that this time, the two lambda expressions are evaluated in the frame \lstinline{f#0}. When any of the procedures get invoked now, it'll no longer be able to find binding of the other.

\section{Exercise 4.21}

\subsection{a.}

It might be clearer to write the procedure as following:

\begin{lstlisting}
(define fact-helper
  (lambda (f k)
    (if (= k 1)
        1
        (* k (f f (- k 1))))))
(define fact
  (lambda (n)
    (fact-helper fact-helper n)))
\end{lstlisting}

Notice that the usage of \lstinline{define} here is just for clarity. One can replace all identifiers with corresponding values and still get a working procedure. The basic idea here is to pass the procedure itself in as an extra argument so that it can refer to itself and make recursive calls (of course it also needs to pass itself in when making recursive calls).

The Fibonacci number procedure can be implemented as follows:

\begin{lstlisting}
;; simple, plain version
(define (fib n)
  (if (< n 2)
      0
      (+ (fib (- n 1))
         (fib (- n 2)))))

;; special version
(define fib-helper
  (lambda (f n)
    (if (< n 2)
        0
        (+ (f f (- n 1))
           (f f (- n 2))))))
(define fib
  (lambda (n)
    (fib-helper fib-helper n)))
\end{lstlisting}

\subsection{b.}

Code:

\begin{lstlisting}
(define (f x)
  ((lambda (even? odd?)
     (even? even? odd? x))
    (lambda (ev? od? n)
      (if (= n 0) #t (od? ev? od? (- n 1))))
    (lambda (ev? od? n)
      (if (= n 0) #f (ev? ev? od? (- n 1))))))
\end{lstlisting}

Test:

\begin{lstlisting}
(map f '(1 2 3 4 5 6 7 8 9))
\end{lstlisting}

Result:

\begin{lstlisting}
(#f #t #f #t #f #t #f #t #f)
\end{lstlisting}

\section*{Complete code of evaluator}

Before moving on, I think it's necessary to gather the code of the evaluator so that further code can be run and tested.

Code:

\begin{lstlisting}
(define system-eval eval)
(define system-apply apply)

;; eval
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (quote-content exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((let? exp) (eval (let->application exp) env))
        ((let*? exp) (eval (let*->let exp) env))
        ((letrec? exp) (eval (letrec->let exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- eval" exp))))

;; apply
(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (else
         (error "Unknown procedure type -- apply" procedure))))

;; self-evaluating
(define (self-evaluating? exp)
  (or (number? exp)
      (string? exp)
      (null? exp)))

;; variable
(define (variable? exp) (symbol? exp))

;; quotation
;; (quote text)
(define (quoted? exp) (tagged-list? exp 'quote))
(define (quote-content exp) (cadr exp))

;; assignment
;; (set! variable value)
(define (assignment? exp) (tagged-list? exp 'set!))
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env)
                       env))
(define (make-assignment variable value)
  (list 'set! variable value))

;; definition
;; (define variable value)
;; or
;; (define (var param0 param1 ... paramn) exp0 exp1 ... expn)
(define (definition? exp)
  (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)
                   (cddr exp))))
(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env))

;; conditional
;; (if predicate consequent alternative)
;; or
;; (if predicate consequent)
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (null? (cdddr exp))
      'undefined
      (cadddr exp)))
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))

;; lambda
;; (lambda (param0 param ... paramn) exp0 exp1 ... expn)
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))

;; sequence
;; (begin exp0 exp1 ... expn)
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (no-exps? seq) (null? seq))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
(define (sequence->exp seq)
  (cond ((no-exps? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))
(define (eval-sequence exps env)
  (cond ((no-exps? exps)
         (error "Empty sequence -- eval-sequence"))
        ((last-exp? exps)
         (eval (first-exp exps) env))
        (else (eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))

;; cond
;; (cond ((p0 e00 e01 ... e0n) (p1 e10 e11 ... e1n) ...))
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (clause-predicate clause) 'else))
(define (clause-predicate clause) (car clause))
(define (clause-actions clause) (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
  (if (null? clauses)
      'undefined
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (clause-actions first))
                (error "Else clause isn't last clause -- cond->if"))
            (make-if (clause-predicate first)
                     (sequence->exp (clause-actions first))
                     (expand-clauses rest))))))

;; let
;; (let bindings body)
(define (let? exp) (tagged-list? exp 'let))
(define (let-bindings exp) (cadr exp))
(define (let-body exp) (cddr exp))
(define (let-no-bindings? bindings) (null? bindings))
(define (let-first-binding bindings) (car bindings))
(define (let-rest-bindings bindings) (cdr bindings))
(define (let-binding-var binding) (car binding))
(define (let-binding-val binding) (cadr binding))
(define (let->application exp)
  (let* ((bindings (let-bindings exp))
         (body (let-body exp))
         (variables (map let-binding-var bindings))
         (values (map let-binding-val bindings)))
   (cons (make-lambda variables
                      body)
         values)))
(define (make-let bindings body)
  (cons 'let (cons bindings body)))

;; let*
;; (let* bindings body)
(define (let*? exp) (tagged-list? exp 'let*))
(define (let*->let exp)
  (define (transform-bindings bindings)
    (if (let-no-bindings? (let-rest-bindings bindings))
        (make-let (list (let-first-binding bindings))
                  (let-body exp))
        (make-let (list (let-first-binding bindings))
                  (list (transform-bindings (let-rest-bindings bindings))))))
  (if (let-no-bindings? (let-bindings exp))
      (sequence->exp (let-body exp))
      (transform-bindings (let-bindings exp))))

;; letrec
;; (letrec bindings body)
(define (letrec? exp) (tagged-list? exp 'letrec))
(define (letrec->let exp)
  (define (create-empty-bindings vars)
    (map (lambda (var) (list var (list 'quote 'unassigned)))
         vars))
  (define (insert-assignments bindings exps)
    (define (insert-helper bindings)
      (if (null? bindings)
          exps
          (cons (make-assignment (caar bindings)
                                 (cadar bindings))
                (insert-helper (cdr bindings)))))
    (insert-helper bindings))
  (let ((bindings (let-bindings exp))
        (body (let-body exp)))
    (if (let-no-bindings? bindings)
        (sequence->exp body)
        (make-let (create-empty-bindings (map let-binding-var
                                              bindings))
                  (insert-assignments bindings body)))))

;; application
;; (op arg0 arg1 ... argn)
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? operands) (null? operands))
(define (first-operand operands) (car operands))
(define (rest-operands operands) (cdr operands))
(define (no-exps? exps) (null? exps))
(define (first-exp exps) (car exps))
(define (rest-exps exps) (cdr exps))
(define (list-of-values exps env)
  ;; expressions evaluated from left to right
  (if (no-exps? exps)
      '()
      (let ((first-value (eval (first-exp exps) env)))
        (cons first-value
              (list-of-values (rest-exps exps) env)))))

;; procedure (value)
;; (procedure parameters body env)
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))

;; environment
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
(define (make-frame variables values)
  (list (map cons variables values)))
(define (frame-variables frame)
  (map car (car frame)))
(define (frame-values frame)
  (map cdr (car frame)))
(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons (cons var val) (car frame)))
  'undefined)
(define (extend-environment vars vals base-env)
  (let ((var-num (length vars))
        (val-num (length vals)))
    (cond ((= var-num val-num)
           (cons (make-frame vars vals) base-env))
          ((> var-num val-num)
           (error "Too many variables -- extend-environment"))
          (else
           (error "Too many values -- extend-environment")))))
(define (frame-traversal env operation)
  (if (eq? env the-empty-environment)
      (error "nothing found during frame traversal")
      (let ((first-frame-result (operation (first-frame env))))
        (if first-frame-result
            first-frame-result
            (frame-traversal (enclosing-environment env)
                             operation)))))
(define (binding-traversal frame operation)
  (define (helper bindings)
    (if (null? bindings)
        #f
        (let ((first-binding-result (operation (car bindings))))
          (if first-binding-result
              first-binding-result
              (helper (cdr bindings))))))
  (helper (car frame)))
(define (lookup-variable-value var env)
  (car (frame-traversal
         env
         (lambda (frame)
           (binding-traversal
             frame
             (lambda (binding)
               (if (eq? var (car binding))
                   (list (cdr binding))
                   #f)))))))
(define (set-variable-value! var val env)
  (frame-traversal
    env
    (lambda (frame)
      (binding-traversal
        frame
        (lambda (binding)
          (if (eq? var (car binding))
              (begin (set-cdr! binding val)
                     'ok)
              #f))))))
(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (if (binding-traversal frame
                           (lambda (binding)
                             (if (eq? var
                                      (car binding))
                                 (begin (set-cdr! binding val)
                                        'ok)
                                 #f)))
        'undefined
        (add-binding-to-frame! var val frame))))

;; primitive
(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))
(define primitive-procedures
  (list (list '+ +)
        (list '- -)
        (list '* *)
        (list 'quotient quotient)
        (list 'remainder remainder)
        (list 'modulo modulo)
        (list '> >)
        (list '< <)
        (list '= =)
        (list 'not not)
        (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)))
(define (primitive-procedure-names)
  (map car primitive-procedures))
(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))
(define (apply-primitive-procedure proc args)
  (system-apply (primitive-implementation proc)
                args))

;; utils
(define (tagged-list? exp tag)
  (and (pair? exp)
       (eq? (car exp) tag)))
(define (true? x)
  (not (false? x)))
(define (false? x)
  (eq? x #f))

;; setups
(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    (define-variable! 'undefined 'undefined initial-env)
    initial-env))
(define the-global-environment (setup-environment))
(define (driver-loop)
  (define (prompt-for-input)
    (define input-prompt ">>> ")
    (newline)
    (display input-prompt))
  (define (announce-output)
    (define output-prompt "<<< ")
    (display output-prompt))
  (define (user-print object)
    (if (compound-procedure? object)
        (display (list 'compound-procedure
                       (procedure-parameters object)
                       (procedure-body object)))
        (display object)))
   (prompt-for-input)
   (let ((input (read)))
     (let ((output (eval input the-global-environment)))
       (announce-output)
       (user-print output)
       (newline)))
   (driver-loop))
\end{lstlisting}











\end{document}
