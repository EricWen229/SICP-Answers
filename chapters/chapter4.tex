\documentclass[../main.tex]{subfiles}

\usepackage{hyperref}

\makeatletter
\ifx\codedir\@undefined\def\codedir{../code}\fi
\makeatother

\begin{document}

\section{Exercise 4.1}

Code:

\begin{lstlisting}
;; left to right version
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (let ((first (eval (first-operand exps) env)))
        (cons first
              (list-of-values (rest-operands exps) env)))))

;; right to left version
(define (list-of-value exps env)
  (if (no-operands? exps)
      '()
      (let ((rest (list-of-values (rest-operands exps) env)))
        (cons (eval (first-operand exps) env)
              rest))))
\end{lstlisting}

\section{Exercise 4.2}

\subsection{a.}

The evaluator will regard \lstinline{(define x 3)} as procedure
application instead of variable definition. Essentially this is
because there lacks a robust way of distinguish different types
of expressions.

\subsection{b.}

Feel sorry for you Louis, really. I understand your feeling.

Code:

\begin{lstlisting}
(define (application? exp) (tagged-list? exp 'call))
(define (operator exp) (cadr exp))
(define (operands exp) (cddr exp))
\end{lstlisting}

\section{Exercise 4.3}

Code:

\begin{lstlisting}
(define (eval exp env)
  ((get 'eval (type exp)) exp env))
(define type car)
(define content cdr)

;; sample evaluation rule
(let ((eval-if
       (lambda (exp env)
               (if (true? (eval (if-predicate exp) env))
                   (eval (if-consequent exp) env)
                   (eval (if-alternative exp) env)))))
  (put 'eval 'if eval-if))                
\end{lstlisting}

\section{Exercise 4.4}

\subsection{Syntax definition}

Code:

\begin{lstlisting}
(define (and? exp) (tagged-list? exp 'and))
(define and-clauses cdr)

(define (or? exp) (tagged-list? exp 'or))
(define or-clauses cdr)

(define no-clauses? null?)
(define first-clause car)
(define rest-clauses cdr)
\end{lstlisting}

\subsection{Special form evaluation}

Code:

\begin{lstlisting}
(define (eval-and exp env)
  (define (eval-and-clauses clauses)
    (cond ((no-clauses? clauses) #t)
          ((true? (eval (first-clause clauses) env))
           (eval-and-clauses (rest-clauses clauses)))
          (else #f)))
  (eval-and-clauses (and-clauses exp)))

(define (eval-or exp env)
  (define (eval-or-clauses clauses)
    (cond ((no-clauses? clauses #f))
          ((true? (eval (first-clause clauses) env)) #t)
          (else (eval (rest-clauses clauses env)))))
  (eval-or-clauses (or-clauses exp)))
\end{lstlisting}

\subsection{Derived form evaluation}

Code:

\begin{lstlisting}
;; transform AST-and to AST-if
(define (and-to-if exp)
  (define (expand-clauses clauses)
    (if (no-clauses? clauses)
        'true
        (make-if (first-clause clauses)
                 (expand-clauses (rest-clauses clauses))
                 'false)))
  (expand-clauses (and-clauses exp)))

;; transform AST-or to AST-if
(define (or-to-if exp)
  (define (expand-clauses clauses)
    (if (no-clauses? clauses)
        'false
        (make-if (first-clause clauses)
                 'true
                 (expand-clauses (rest-clauses clauses)))))
  (expand-clauses (or-clauses exp)))
\end{lstlisting}

\section{Exercise 4.5}

One thing noteworthy is that the recipient
procedure is invoked on the value of the expression
(result of evaluating it), not the expression itself.
The expression is only evaluated once, after which
its value is used for both branching and possibly
recipient. Thus the condition branch
\lstinline{(#test-exp => #recipient)} should be
transformed to the following expression:

\begin{lstlisting}
(let ((exp-value #test-exp))
  (if exp-value
      (#recipient exp-value)
      ;; other branches
))
\end{lstlisting}

This introduces the same problem as macros do. The local
variable \lstinline{exp-value} could introduce name conflict
with another variable named \lstinline{exp-value} in other branches,
therefore shadow the previous definition of that variable.
And, the variable binding of \lstinline{exp-value}
isn't supposed to leak into other branches and possibly
let expressions in other branches refer to it, which should've
caused an unbound variable error.

The problem seems inevitable for now. One way to tackle it is to use
the same technique as macros do to avoid name conflict. Another way
is to treat \lstinline{cond} expressions as a special form and
make the intermediate variable \lstinline{exp-value} only exist
at runtime (during the evaluation of the \lstinline{cond}
expression).

\section{Exercise 4.6}

Code:

\begin{lstlisting}
;; let expression format:
;; (let bindings body)
;;
;; bindings format:
;; (binding0 binding1 binding2 ...)
;;
;; binding format:
;; (var . exp)

(define (let? exp) (tagged-list? exp 'let))
(define let-bindings cadr)
(define let-body caddr)
(define no-bindings? null?)
(define first-binding car)
(define rest-bindings cdr)
(define binding-var car)
(define binding-exp cdr)

(define (let->combination let-exp)
  (let* ((bindings (let-bindings let-exp))
         (body (let-body let-exp))
         (parameters (map binding-var bindings))
         (arguments (map binding-exp bindings)))
    (cons (make-lambda parameters body)
          arguments)))
\end{lstlisting}

\section{Exercise 4.7}

Code:

\begin{lstlisting}
(define (let*->nested-lets let*-exp)
  (define (transform-bindings bindings)
    (if (no-bindings? bindings)
        (let*-body let*-exp)
        (make-let (list (first-binding bindings))
                  (transform-bindings (rest-bindings bindings)))))
  (transform-bindings (let*-bindings let*-exp)))
\end{lstlisting}

It is sufficient since the second call to \lstinline{eval} will
perform another dispatch to handle \lstinline{let} expression, where
the \lstinline{let} expression will be transformed to combination
and evaluated.

\section{Exercise 4.8}

We already know that a \lstinline{let} expression is equivalent
to function application. Named \lstinline{let} is no different, where
the function being applied can be recursive now. The expression
\lstinline{(let #var #bindings #body)} is equivalent to:

\begin{lstlisting}
(let ((#var (lambda (#parameters) #body)))
  (#var #arguments))
\end{lstlisting}

Thus the transformation can be implemented as follows:

\begin{lstlisting}
;; here I'll just leave out the dispatch and implement transformation
;; from named let to combination

(define (named-let->let named-let-exp)
  (let* ((var (named-let-var named-let-exp))
         (bindings (named-let-bindings named-let-exp))
         (body (named-let-body named-let-exp))
         (parameters (map binding-var bindings))
         (arguments (map binding-exp bindings)))
    (make-let (list (cons var
                          (make-lambda parameters
                                       body)))
              (cons var arguments))))

(define (named-let->combination named-let-exp)
  (let->combination (named-let->let named-let-exp)))
\end{lstlisting}

\section{Exercise 4.9}

Basically we're defining a syntactic sugar. Let's define a
\lstinline{while} construct. First the syntax:

\begin{lstlisting}
(while #condition #exp)
\end{lstlisting}

It's equivalent to:

\begin{lstlisting}
(if #condition
    (begin #exp
           (while #condition #exp))
    'ok)
\end{lstlisting}

It's quite noteworthy that it's a recursive definition. We
can actually define this as a macro (tested in Racket):

\begin{lstlisting}
(define-syntax-rule (while condition exp)
  (letrec ((loop
            (lambda ()
              (if condition
                  (begin exp
                         (loop))
                  'ok))))
    (loop)))
\end{lstlisting}

Some simple test:

\begin{lstlisting}
(let ((x 10))
  (while (> x 0)
         (begin (display x)
                (newline)
                (set! x (- x 1)))))
\end{lstlisting}

Result:

\begin{lstlisting}
10
9
8
7
6
5
4
3
2
1
'ok
\end{lstlisting}

\section{Exercise 4.10}

Modifying implementation of constructors and selectors will do.
Since they are the only interfaces across which \lstinline{eval}
and \lstinline{apply} access and manipulate the program, thest two
methods won't need any modification. The specific code is left as
an exercise to the readers ;)

\section{Exercise 4.11}

Code:

\begin{lstlisting}
(define (make-frame variables values)
  (list (map cons variables values)))

(define (frame-variables frame)
  (map car (car frame)))

(define (frame-values frame)
  (map cdr (car frame)))

(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons (cons var val) (car frame))))
\end{lstlisting}

\section{Exercise 4.12}

The lookup procedure is as follows:

\begin{itemize}
\item traverse all frames
\item for every frame, traverse its bindings
\item if binding matched, return value of it
\end{itemize}

The set procedure is as follows:

\begin{itemize}
\item traverse all frames
\item for every frame, traverse its bindings
\item if binding matched, set value of it
\end{itemize}

The define procedure is as follows:

\begin{itemize}
\item for the first frame, traverse its bindings
\item if binding matched, set value of it
\item if none matched, insert new binding
\end{itemize}

These operations can be extracted from above:

\begin{itemize}
\item frame traversal
\item binding traversal
\end{itemize}

Code:

\begin{lstlisting}
(define (frame-traversal env operation)
  (if (eq? env the-empty-environment)
      (error "nothing found during frame traversal")
      (let ((first-frame-result (operation (first-frame env))))
        (if first-frame-result
            first-frame-result
            (frame-traversal (enclosing-environment env)
                             operation)))))

;; binding defined as list of pairs
(define (binding-traversal frame operation)
  (define (helper bindings)
    (if (null? bindings)
        #f
        (let ((first-binding-result (operation (car bindings))))
          (if first-binding-result
              first-binding-result
              (helper (cdr bindings))))))
  (helper (car frame)))

(define (lookup-variable-value var env)
  (frame-traversal
    env
    (lambda (frame)
      (binding-traversal
        frame
        (lambda (binding)
          (if (eq? var (car binding))
              (cdr binding)
              #f))))))

(define (set-variable-value! var val env)
  (frame-traversal
    env
    (lambda (frame)
      (binding-traversal
        frame
        (lambda (binding)
          (if (eq? var (car binding))
              (begin (set-cdr! binding val)
                     'ok)
              #f))))))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (if (binding-traversal frame
                           (lambda (binding)
                             (if (eq? var
                                      (car binding))
                                 (begin (set-cdr! binding val)
                                        'ok)
                                 #f)))
        'ok
        (add-binding-to-frame! var val frame))))
\end{lstlisting}

\section{Exercise 4.13}

There are several cases to consider:

\begin{enumerate}
\item the binding is only in the first frame
\item the binding is only in the enclosing environment
\item the binding is in both the first frame and the enclosing environment
\item the binding is in neither the first frame nor the enclosing
environment
\end{enumerate}

Except for the fourth case where nothing can be done, the other three
need careful consideration.

But why does anyone want to get rid of bindings?

It turns out that this could be useful for imperative style programming,
where there could be something like:

\begin{lstlisting}
(define (square-sum a b)
  (define sum 0)
  (define term-squared 0)
  (set! term-squared (* a a))
  (set! sum (+ sum term-squared))
  (set! term-squared (* b b))
  (set! sum (+ sum term-squared))
  (make-unbound! term-squared)
  ; get rid of this binding
  ; so that some other careless guy
  ; can never carelessly refer to it later
  sum)
\end{lstlisting}

This is stupid. What is supposed to be done easily and safely with
scope now requires programmers to manually intervene. While in Python
this does make some sense, where they can't even implement the scope
of loops correctly:

\begin{lstlisting}[language=Python]
for i in range(10):
  print(i)

# loops don't create new scope
# so you can still access it
# amazing
print(i)

# get rid of it
del i
\end{lstlisting}

\section{Exercise 4.14}

The system version of \lstinline{map} expects the procedure to be
defined in the environment of the evaluator, not that of user program.
This is confusing since we're implementing a Scheme evaluator using
Scheme itself. Considering the situation where we're implementing a Python
interpreter using Scheme helps to understand the problem. Given the
procedure argument (as a symbol), Louis's \lstinline{map} will look for
a Scheme procedure in the environment of the interpreter instead of a
Python procedure in the environment of the user program.

\section{Exercise 4.15}

If evaluating \lstinline{(try try)} halts, it indicates that evaluating
\lstinline{(halts? try try)} returns \lstinline{#f}. Thus, from the
definition of \lstinline{halts?} we know that \lstinline{try} doesn't
halt on \lstinline{try}, which leads to a contradiction with the fact
that \lstinline{(try try)} halts at the very beginning.

If evaluating \lstinline{(try try)} runs forever, it indicates that
evaluating \lstinline{(halts? try try)} returns \lstinline{#t}, from
which we know that \lstinline{try} does halt on \lstinline{try}.
Contradiction again. Any possible outcome of evaluating
\lstinline{(try try)} violates the intended behaviour of
\lstinline{halts?}.

\section{Exercise 4.16}

\subsection{a.}

Code:

\begin{lstlisting}
(define (lookup-variable-value var env)
  (frame-traversal
    env
    (lambda (frame)
            (binding-traversal
              frame
              (lambda (binding)
                      (if (eq? var
                               (car binding))
                          (if (eq? (cdr binding)
                                   '*unassigned)
                              (error "Unsigned variable"
                                     var)
                              (cdr binding))
                          #f))))))
\end{lstlisting}

\subsection{b.}

Code:

\begin{lstlisting}
;; (lambda (...) (define u #e1) (define v #e2) ...)
;; to
;; (lambda (...) (let ((u ...) (v ...)) (set! u ...) (set! v ...) ...)

(define (scan-out-defines exp)
  (define (extract-defines exp)
    (cond ((definition? exp)
           (list (cons (definition-variable exp)
                       (definition-value exp))))
          ((begin? exp)
           (let ((exps (begin-actions exp)))
             (foldr append
                    '()
                    (map extract-defines
                         exps))))
          (else '())))
  (define (remove-defines exp)
    (if (begin? exp)
        (make-begin (map remove-defines
                         (filter (lambda (exp)
                                   (not (definition? exp)))
                                 (begin-actions exp))))
        exp))
  (define (create-empty-bindings variables)
    (map (lambda (var) (cons (var '*unassigned*)))
         variables))
  (define (insert-assignments definitions exp)
    (define (insert-helper definitions exp)
      (if (null? definitions)
          (list exp)
          (cons (make-assignment (caar definitions)
                                 (cdar definitions))
                (insert-helper (cdr definitions)
                               exp))))
    (make-begin (insert-helper definitions exp)))
  (let ((local-definitions (extract-defines exp)))
    (if (null? local-definitions)
        exp
        (let ((variables (map car
                              local-definitions)))
          (make-let (create-empty-bindings variables)
                    (insert-assignments local-definitions exp))))))
\end{lstlisting}

\subsection{c.}

Installing in \lstinline{make-procedure} is better, ensuring \lstinline{scan-out-defines} is only invoked once.

\section{Exercise 4.17}

Sequentially interpreted environment:

\begin{lstlisting}
  environment
  where lambda
  got evaluated
        ^
        |
+---------------------+
| (argument bindings) |
| u: value of e1      | env0
| v: value of e2      |
+---------------------+
\end{lstlisting}

Scanned out environment:

\begin{lstlisting}
  environment
  where lambda
  got evaluated
        ^
        |
+---------------------+
| (argument bindings) | env1
+---------------------+
        ^
        |
+----------------+
| u: value of e1 | env2
| v: value of e2 |
+----------------+
\end{lstlisting}

The extra frame is created by the \lstinline{let} expression.

The difference in environment can never make a difference in the behaviour of a correct program, since the evaluation of $e3$ can access the exact same set of bindings (\lstinline{u}, \lstinline{v}, arguments and those in enclosing environment) whether it's evaluated in \lstinline{env0} or \lstinline{env2}.

To implement the simultaneous scope rule for internal definitions without any extra frames, one can make the evaluator evaluate a block structure in two passes, in the first of which the evaluator evaluates every internal definition before evaluating any other expressions. Also one
can perform a transform on the AST to move all internal definitions to block structures' beginning.

\section{Exercise 4.18}

Expanding the procedure produces code as following:

\begin{lstlisting}
(define solve
  (lambda (f y0 dt)
    (let ((y '*unassigned*)
          (dy '*unassigned*))
      (let ((a (integral (delay dy) y0 dt))
            (b (stream-map f y)))
        (set! u a)
        (set! v b))
      y)))
\end{lstlisting}

This won't work. When evaluating the inner \lstinline{let} expression, \lstinline{(stream-map f y)} is eagerly evaluated while \lstinline{y} is bound to nothing.

If expanded as shown in the text:

\begin{lstlisting}
(define solve
  (lambda (f y0 dt)
    (let ((y '*unassigned*)
          (dy '*unassigned*))
      (set! y (integral (delay dy) y0 dt))
      (set! dy (stream-map f y))
      y)))
\end{lstlisting}

The second version works correctly, as \lstinline{y} is already assigned with valid value before \lstinline{(stream-map f y)} is evaluated.

To accommodate the first approach to this problem, delayed evaluation is needed (i.e. \lstinline{y} must not be eagerly evaluated).

\section{Exercise 4.19}

Now there are three opinions on the table:

\begin{itemize}
\item Ben: binding created and variable assigned after definition expression is evaluated
\item Alyssa: binding created when enter scope, but variable assigned after definition expression is evaluted
\item Eva: binding created and variable assigned when enter scope
\end{itemize}

Ben's suggestion appears quite "dynamic" to me. This is pretty straightforward and easy to implement, as the semantic here corresponds well to the evaluation process. But what makes it much less appealing is that it requires knowing the entire history to determine its current state, which would make the program way harder to reason about.
The most common intention behind defining a local variable possibly is to shadow any other outer variables, where such semantic would be quite counterintuitive.

Eva's suggestion, on the other hand, looks far more "lexical". And this is the most graceful one as I see it. The problem, however, arises from the reality. Firstly we have the efficiency issue, which is very little likely to be solvable. Also, it may seem confusing when the local variables are assigned at the very beginning, as if it happens before definition expressions are evaluated. Instead of the entire history, now it requires knowing its entire scope to determine its current state.

I personally favor Alyssa's suggestion most. Externally, the definitions are shadowed by internal definitions, allowing the programmer to think fully "locally". Internally, the definitions are processed in a quite "dynamic" way, letting the programmer to track internal definitions in a quite nature and straightforward way.

Now, before implementing the semantic as Eva suggests, notice that moving internal definitions to the beginning is no longer adequate. The order also matters, as shown in the example. \lstinline{a} should be already holding the value 5 before \lstinline{(+ a x)} is evaluated.

If there is a valid order, say, we can process definitions once at a time in some order, where each definition being processed doesn't need any other definitions that aren't processed yet, then we can use topological sort on dependency graph of definitions to discover such an order and rearrange internal definitions.

What if there's no valid orders? Take this expression for example:

\begin{lstlisting}
(define (some-function x)
  (define foo (+ x bar))
  (define bar (* x foo))
  (+ foo bar))
\end{lstlisting}

There's no way we can devise a valid semantic for this. What's worse is that such situation could be much harder to detect in real world scenarios, as the cycle could get much larger. Of course, we can run cycle detection on the dependency graph of definitions before performing topological sort, but now the whole process is going to be really complex and inefficient.

\section{Exercise 4.20}

\subsection{a.}

Code:

\begin{lstlisting}
;; transform
;; (letrec ((v0 e0) (v1 e1) ... (vn en)) body)
;; to
;; (let ((v0 'unassigned)
;;       (v1 'unassigned)
;;       ...
;;       (vn 'unassigned))
;;   (set! v0 e0)
;;   (set! v1 e1)
;;   ...
;;   (set! vn en)
;;   body)

;; definition of letrec
;; format: (letrec bindings body)
(define (letrec? exp) (tagged-list? exp 'letrec))
(define letrec-bindings cdar)
(define letrec-body cddar)
(define no-bindings? null?)
(define first-binding car)
(define rest-binding cdr)
(define binding-var car)
(define binding-exp cdr)

(define (letrec->let exp)
  (let ((bindings (letrec-bindings exp))
        (body (let-rec-body exp)))
    (make-let (create-empty-bindings (map binding-var
                                          bindings))
              (insert-assignments bindings body))))
\end{lstlisting}

\subsection{b.}

Environment with \lstinline{letrec}:

\begin{lstlisting}
+------+
| f#0  |
| ---- |
| x: 5 |
+------+
    ^
    |
+---------------------------------------------+
| letrec#0                                    |
| ------------------------------------------- |
| even?: (lambda (n) (...odd?...)) @ letrec#0 |
| odd?: (lambda (n) (...even?...)) @ letrec#0 |
+---------------------------------------------+
\end{lstlisting}

Notice that the lambda expressions of \lstinline{even?} and \lstinline{odd?} are both evaluated in the frame \lstinline{letrec#0}, thus their environments are both \lstinline{letrec#0}. When any of the procedures, like \lstinline{even?}, get invoked, the body will be evaluated in a new frame whose enclosing environment points to \lstinline{letrec#0}. Therefore, when it looks for \lstinline{odd?} in the environment, it'll find the binding in frame \lstinline{letrec#0}

Environment with \lstinline{let}:

\begin{lstlisting}
+------+
| f#0  |
| ---- |
| x: 5 |
+------+
    ^
    |
+----------------------------------------+
| let#0                                  |
| -------------------------------------- |
| even?: (lambda (n) (...odd?...)) @ f#0 |
| odd?: (lambda (n) (...even?...)) @ f#0 |
+----------------------------------------+
\end{lstlisting}

Notice that this time, the two lambda expressions are evaluated in the frame \lstinline{f#0}. When any of the procedures get invoked now, it'll no longer be able to find binding of the other.

\section{Exercise 4.21}

\subsection{a.}

It might be clearer to write the procedure as following:

\begin{lstlisting}
(define fact-helper
  (lambda (f k)
    (if (= k 1)
        1
        (* k (f f (- k 1))))))
(define fact
  (lambda (n)
    (fact-helper fact-helper n)))
\end{lstlisting}

Notice that the usage of \lstinline{define} here is just for clarity. One can replace all identifiers with corresponding values and still get a working procedure. The basic idea here is to pass the procedure itself in as an extra argument so that it can refer to itself and make recursive calls (of course it also needs to pass itself in when making recursive calls).

The Fibonacci number procedure can be implemented as follows:

\begin{lstlisting}
;; simple, plain version
(define (fib n)
  (if (< n 2)
      0
      (+ (fib (- n 1))
         (fib (- n 2)))))

;; special version
(define fib-helper
  (lambda (f n)
    (if (< n 2)
        0
        (+ (f f (- n 1))
           (f f (- n 2))))))
(define fib
  (lambda (n)
    (fib-helper fib-helper n)))
\end{lstlisting}

\subsection{b.}

Code:

\begin{lstlisting}
(define (f x)
  ((lambda (even? odd?)
     (even? even? odd? x))
    (lambda (ev? od? n)
      (if (= n 0) #t (od? ev? od? (- n 1))))
    (lambda (ev? od? n)
      (if (= n 0) #f (ev? ev? od? (- n 1))))))
\end{lstlisting}

Test:

\begin{lstlisting}
(map f '(1 2 3 4 5 6 7 8 9))
\end{lstlisting}

Result:

\begin{lstlisting}
(#f #t #f #t #f #t #f #t #f)
\end{lstlisting}

\section{Exercise 4.22}

Code:

\begin{lstlisting}
;; one of the branches in analyze
((let? exp) (analyze (let->application exp)))
\end{lstlisting}

\section{Exercise 4.23}

For a sequence with only one expression, the version in the text would just evaluate that expression by invoking the procedure with current environment, while Alyssa's version would first check if there's a second expression before evaluating the first one.

Things are similar for sequences with two expressions. The version in the text is informed of when to stop during analysis, which Alyssa's version determines when to stop at runtime.

\section{Exercise 4.24}

Benchmark code:

\begin{lstlisting}
(define (benchmark thunk)
  (with-timings
    thunk
    (lambda (runtime gctime realtime)
      (display "runtime: ")
      (display (internal-time/ticks->seconds runtime))
      (newline)
      (display "gctime: ")
      (display (internal-time/ticks->seconds gctime))
      (newline)
      (display "realtime: ")
      (display (internal-time/ticks->seconds realtime))
      (newline))))
(define (create-benchmark-thunk eval-to-use code)
  (let ((env (setup-environment)))
    (lambda () (eval-to-use code env))))
;; here I use the slow version on purpose
;; to increate number of recursive calls
(define samplecode
  (quote
    (letrec ((fib (lambda (n)
                    (if (< n 2)
                        1
                        (+ (fib (- n 1))
                           (fib (- n 2)))))))
      (fib 23))))
(benchmark (create-benchmark-thunk eval samplecode))
(benchmark (create-benchmark-thunk eval-with-analysis samplecode))
\end{lstlisting}

Result:

\begin{lstlisting}
1 ]=> (benchmark (create-benchmark-thunk eval samplecode))
runtime: 18.07
gctime: .14
realtime: 20.863
;Value: 46368

1 ]=> (benchmark (create-benchmark-thunk eval-with-analysis samplecode))
runtime: 9.1
gctime: .09
realtime: 10.078
;Value: 46368
\end{lstlisting}

\section{Exercise 4.25}

Evaluating \lstinline{(factorial 5)} causes infinite recursion.

Our definition will work in a normal-order language (where \lstinline{(* n (factorial (- n 1)))} is evaluated if and only if $n \neq 1$).

\section{Exercise 4.26}

As a special form, \lstinline{unless} is just like \lstinline{if} except order of parameters.

On the other hand, as a procedure, \lstinline{unless} can be useful in binary selection (a great example from \url{https://github.com/qiao/sicp-solutions}):

\begin{lstlisting}
(define select-y '(#t #f #t #t)) 
(define xs '(1 3 5 7)) 
(define ys '(2 4 6 8)) 
(define selected (map unless select-y xs ys))
\end{lstlisting}

\lstinline{unless} absolutely fits the need here, but it can totally be replaced with a \lstinline{lambda}:

\begin{lstlisting}
(define select-y '(#t #f #t #t)) 
(define xs '(1 3 5 7)) 
(define ys '(2 4 6 8)) 
(define selected
  (map (lambda (select-b a b)
         (if select-b
             b
             a))
       select-y
       xs
       ys))
\end{lstlisting}

The code is a little bit longer than before, but is much clearer to whoever's reading it. Those who don't know the usage of \lstinline{unless} don't need to go to the documentation, and those who do know it can still gain more confidence about the correctness. Such "convenience" may not be an adequate reason to make \lstinline{unless} a procedure.

\section{Exercise 4.27}

Keep in mind that lazy evaluation:

\begin{itemize}
\item create thunks when procedures are applied
\item force thunks when needed by primitives
\item memoize result of forcing after the first time
\end{itemize}

Now let's take a look at the sequence:

\begin{lstlisting}
(define count 0)

(define (id x)
  (set! count (+ count 1))
  x)

(define w (id (id 10)))

;; when (id (id 10)) is evaluated
;; thunk [(id 10) @ global env] is created
;; count becomes 1
;; w becomes [(id 10) @ global env]

;; L-Eval input:
count
;; L-Eval value:
1

;; L-Eval input:
w
;; L-Eval value:
10

;; w is forced and (id 10) is evaluated
;; count becomes 2
;; w becomes [10] due to memoization

;; L-Eval input:
count
;; L-Eval value:
2
\end{lstlisting}

\section{Exercise 4.28}

Result of evaluating an \lstinline{eval} could be a thunk that returns a procedure object when forced. Here's an example:

\begin{lstlisting}
(define (self x) x)
(define (partial-add a)
  (lambda (b) (+ a b)))
((self (partial-add 1)) 232)
\end{lstlisting}

Evaluating \lstinline{(self (partial-add 1))} returns a thunk whose expression is \lstinline{(partial-add 1)}. It shall be forced before being applied with arguments.

\section{Exercise 4.29}

One perfect example would be how we defined the stream \lstinline{integer} implicitly. As primitive procedures would force all arguments, we have to implement pairs on our own.

Code:

\begin{lstlisting}
(define (cons-stream a b)
  (lambda (i)
    (if i a b)))
(define (stream-car pair)
  (pair true))
(define (stream-cdr pair)
  (pair false))

(define (stream-add s1 s2)
  (cons-stream (+ (stream-car s1)
                  (stream-car s2))
               (stream-add (stream-cdr s1)
                           (stream-cdr s2))))
(define (stream-to-list n stream)
  (if (= n 0)
      ()
      (cons (stream-car stream)
            (stream-to-list (- n 1)
                            (stream-cdr stream)))))
(define (get-nth n stream)
  (if (= n 0)
      (stream-car stream)
      (get-nth (- n 1)
               (stream-cdr stream))))

(define ones (cons-stream 1 ones))
(define (i-from n)
  (cons-stream n (i-from (+ n 1))))

(define integers-explicit (i-from 1))
(define integers-implicit
  (cons-stream 1
               (stream-add ones integers-implicit)))
\end{lstlisting}

Evaluating \lstinline{(get-nth 233 integers-implicit)} takes a blink of an eye with memoization. Evaluating the same expression without memoization takes way longer, which is about 20 seconds.

Back to the sequence in the text. When evaluator memoizes, \lstinline{(id 10)} is only evaluated once during the evaluation of \lstinline{(square (id 10))}, thus value of \lstinline{count} is 1 at the end. When there's no memoization, \lstinline{(id 10)} are evaluated twice, causing \lstinline{count} to be incremented twice.

\section{Exercise 4.30}

\subsection{a.}

Ben is right because \lstinline{display} will force \lstinline{x}.

\subsection{b.}

In the original version, evaluating \lstinline{(p1 1)} returns \lstinline{(1 2)}, while evaluating \lstinline{(p2 1)} returns \lstinline{1}.

In Cy's version, both expressions return \lstinline{(1 2)} as \lstinline{e} is forced now.

\subsection{c.}

Because the result of evaluating \lstinline{(proc (car items))} is discarded and forcing it doesn't make any difference.

\subsection{d.}

While browsing the discussions about this on the Internet, I found some really interesting ideas. Some say that the internal expressions should not be strictly forced because their values are merely discarded and the evaluator should only force a thunk as is needed. There's also a quite interestring claim that says all expressions in a sequence except for the last one are only there for the side effects they produce.

Personally I prefer a combination of these two ideas. Indeed the evaluator should only force a thunk only if it's needed, as is indicated by the name call-by-need, but we need an expression not only for its value, but also for its side effects. In sequences, we've already chosen to discard values of internal expressions. They're only there because we need their side effects, including the side effects of evaluating the result. Therefore, these side effects shouldn't be left out, and I like Cy's approach more.

\section{Exercise 4.31}

See later section.

\section{Exercise 4.32}

Well in some cases where originally explicit \lstinline{delay} is needed, the extra laziness brings some convenience. The \lstinline{car} could be temporarily unaccessible (see the intergral example) or computationally expensive.

Another benefit of the extra laziness is that now we can regard \lstinline{car} and \lstinline{cdr} of a pair equally. If a higher order procedure tends to use either \lstinline{car} or \lstinline{cdr} of a pair (both of them are intended to be delayed), it can have an extra parameter that accepts either \lstinline{car} or \lstinline{cdr}.

\section{Exercise 4.33}

Code:

\begin{lstlisting}
(define (lazify-if-pair value)
  (if (pair? value)
      (pair->lazy-pair value)
      value))
(define (pair->lazy-pair pair)
  (let ([lazified-car (lazify-if-pair (car pair))]
        [lazified-cdr (lazify-if-pair (cdr pair))])
    (make-compound-procedure (list (cons 'standard 'm))
                             (analyze (quote (m x y)))
                             (extend-environment
                              (list (make-binding 'x lazified-car)
                                    (make-binding 'y lazified-cdr))))))
(define (analyze-quote exp)
  (let* ([content (quote-content exp)]
         [lazified-content (lazy-if-pair content)])
    (lambda (env) lazified-content)))
\end{lstlisting}

\section{Exercise 4.34}

Won't bother to implement this. I'll just describe the basic idea.

If pairs are still implemented as compound procedures, there's no way the evaluator can tell the difference between a pair and another compound procedure that happens to have the exact same pattern. It would confuse the user when two procedures are printed out in different formats just because one of them happens to look like a pair. One feasible alternative would be representing lazy pairs with plain pairs:

\begin{lstlisting}
(define (cons (lazy-memo x) (lazy-memo y))
  (system-cons x y))
\end{lstlisting}

Then the evaluator can just treat lazy pairs as plain ones when printing.

As for lists, I just don't feel like handling them :)

\section*{Complete code of evaluator}

Here I've implemented an evaluator with backward compatible lazy evaluation and with analysis technique introduced in section 4.1.7. Since this is a pretty much complete version, code of subsequent exercises will be based on this version.

Code:

\lstinputlisting[language=Lisp]{\codedir/src/chapter4/evaluator.rkt}

Tests:

\lstinputlisting[language=Lisp]{\codedir/test/chapter4/evaluator.scm}

\section{Exercise 4.35}

Code:

\begin{lstlisting}
(define (an-integer-between a b)
  (cond [(< a b)
         (amb a (an-integer-between (+ a 1)
                                    b))]
        [(= a b) a]
        [(> a b) (amb)]))
\end{lstlisting}

\section{Exercise 4.36}

Because DFS will never exhaust all options of the any element of the triple.

Unlike stream where we can interleave two streams, \lstinline{amb} never stops searching one branch until a failure is detected. Thus in order for the program to be able to generate arbitary Pythagorean triples, one need to make sure that the infinite sequence consists of an infinite number of finite branches, so that DFS can stop searching forward at some point and backtrack to other branches.

The essense of this problem is to divide an infinite set into an infinite number of finite sets. One possible way of such division is to do so according to the range where largest element lies:

\begin{lstlisting}
(define (a-pythagorean-triple-with-largest-between low high)
  (let* ([i (an-integer-between 1 high)]
         [j (an-integer-between i high)]
         [k (an-integer-between j high)])
    (require (and (>= k low)
                  (<= k high)
                  (= (+ (* i i)
                        (* j j))
                     (* k k))))
    (list i j k)))
(define (a-pythagorean-triple-with-largest-from low)
  (define step 5)
  (amb (a-pythagorean-triple-with-largest-between low
                                                  (- (+ low step)
                                                     1))
       (a-pythagorean-triple-with-largest-from (+ low step))))
\end{lstlisting}

\section{Exercise 4.37}

In the original version, to generate all Pythagorean triples in range from $low$ to $high$, the number of possibilities that need to be explored is (let $t$ be $high-low+1$):

\begin{align*}
& \sum_{i=low}^{high} \sum_{j=i}^{high} \sum_{k=j}^{high} 1 \\
&= \sum_{i=low}^{high} \frac{(high-i+2)(high-i+1)}{2} \\
&= \frac{1}{2} \sum_{i=high-low}^{0} (i+1)(i+2) \\
&= \frac{1}{2} \sum_{i=high-low+1}^{1} i(i+1) \\
&= \frac{1}{2} \left( \sum_{i=1}^{high-low+1}i + \sum_{i=1}^{high-low+1}i^2 \right) \\
&= \frac{1}{2} \left( \frac{t(t+1)}{2} + \frac{t(t+1)(2t+1)}{6}\right) \\
&= \frac{1}{2} \cdot \frac{t(t+1)(2t+4)}{6} \\
&= \frac{t(t+1)(t+2)}{6}
\end{align*}

In Ben's version, to generate all Pythagorean triples in range from $low$ to $high$, the number of possibilities that need to be explored is:

\begin{align*}
& \sum_{i=low}^{high} \sum_{j=i}^{high} 1 \\
&= \sum_{i=low}^{high} (high - i + 1) \\
&= \sum_{i=high-low}^{0} (i + 1) \\
&= \sum_{i=high-low+1}^{1} i \\
&= \sum_{i=1}^{high-low+1} i \\
&= \frac{t(t+1)}{2}
\end{align*}

Well indeed Ben's version is more efficient. The original version needs to explore $O(N^3)$ possibilities while only $O(N^2)$ possibilities are needed by Ben's version ($N$ is the length of interval).

\section{Exercise 4.38}

Simply remove the following \lstinline{require} expression from the body of \lstinline{multiple-dwelling} will do:

\begin{lstlisting}
;; expression to remove
(require (not (= (abs (- smith fletcher)) 1)))
\end{lstlisting}

\section{Exercise 4.39}

The order doesn't affect the answer but absolutely affects the time. Specifically putting more strict restrictions closer to the head of the body makes the procedure faster.

Consider the following fact. In all $5!=120$ possible cases (in which floor assignments are distict), there are $\frac{1}{2}$ of them in which \lstinline{(> miller cooper)} is true, while there are $\frac{4}{5}$ of them in which \lstinline{(not (= baker 5))} is true. Obviously, \lstinline{(> miller cooper)} is a much rarer situation than \lstinline{(not (= baker 5))}. Thus if we put

\begin{lstlisting}
(require (> miller cooper))
\end{lstlisting}

ahead of

\begin{lstlisting}
(require (not (= baker 5)))
\end{lstlisting}

in the body of \lstinline{multiple-dwelling}, more choices can be failed earlier, which would speed up the procedure.

It's also worthwhile to consider an extreme situation, where there are two \lstinline{require} expressions and one of them applies no actual restrictions (like \lstinline{(require true)}), then there's definitely no benefit putting it before the other.

\section{Exercise 4.40}

Before the distinction restriction there are $5^5=3125$ sets of assignments, and after the restriction there are $5!=120$ sets of assignments.

A more efficient version:

\begin{lstlisting}
(define (multiple-dwelling)
  (let ([baker (amb 1 2 3 4)]
        [cooper (amb 2 3 4 5)]
        [fletcher (amb 2 3 4)])
    (require (not (= (abs (- fletcher cooper)) 1)))
    (let ([miller (amb 3 4 5)])
      (require (> miller cooper))
      (let ([smith (amb 1 2 3 4 5)])
        (require (not (= (abs (- smitch fletcher)) 1)))
        (require
         (distinct? (list baker cooper fletcher miller smitch)))
        (list (list 'baker baker)
              (list 'cooper cooper)
              (list 'fletcher fletcher)
              (list 'miller miller)
              (list 'smith smith))))))
\end{lstlisting}

\section{Exercise 4.41}

Code:

\begin{lstlisting}
(define (member-of? item items)
  (cond [(null? items) #f]
        [(= item (car items)) #t]
        [else (member-of? item (cdr items))]))

(define (distinct? items)
  (cond [(null? items) #t]
        [(null? (cdr items)) #t]
        [(member-of? (car items) (cdr items)) #f]
        [else (distinct? (cdr items))]))

(define (cartesian-product variables)
  (cond [(null? variables)
         (error "No variables provided")]
        [(null? (cdr variables))
         (map (lambda (value)
                (list value))
              (car variables))]
        [else
         (let* ([first-var (car variables)]
                [rest-product (cartesian-product (cdr variables))])
           (foldr append
                  '()
                  (map (lambda (value)
                         (map (lambda (comb)
                                (cons value comb))
                              rest-product))
                       first-var)))]))

(define (combine-predicates-and predicates)
  (cond [(null? predicates)
         (error "No predicates provided")]
        [(null? (cdr predicates))
         (car predicates)]
        [else (lambda (foo)
                (if ((car predicates) foo)
                    ((combine-predicates-and (cdr predicates)) foo)
                    #f))]))

(define (multiple-dwelling)
  (define (assign-baker assign)
    (list-ref assign 0))
  (define (assign-cooper assign)
    (list-ref assign 1))
  (define (assign-fletcher assign)
    (list-ref assign 2))
  (define (assign-miller assign)
    (list-ref assign 3))
  (define (assign-smith assign)
    (list-ref assign 4))
  (define restriction
    (combine-predicates-and
     (list distinct?
           (lambda (assign) (not (= (assign-baker assign)
                                    5)))
           (lambda (assign) (not (= (assign-cooper assign)
                                    5)))
           (lambda (assign) (not (= (assign-fletcher assign)
                                    5)))
           (lambda (assign) (not (= (assign-fletcher assign)
                                    1)))
           (lambda (assign) (> (assign-miller assign)
                               (assign-cooper assign)))
           (lambda (assign) (not (= (abs (- (assign-smith assign)
                                            (assign-fletcher assign)))
                                    1)))
           (lambda (assign) (not (= (abs (- (assign-fletcher assign)
                                            (assign-cooper assign)))
                                    1))))))
  (define values '(1 2 3 4 5))
  (filter restriction
          (cartesian-product
           (list values
                 values
                 values
                 values
                 values))))
\end{lstlisting}

\section{Exercise 4.42}

Code:

\begin{lstlisting}
(define (either predicate1 predicate2)
  (lambda (foo)
    (let ([result1 (predicate1 foo)]
          [result2 (predicate2 foo)])
      (or (and result1
               (not result2))
          (and (not result1)
               result2)))))

(define (liars-puzzle)
  (define (score-betty scores)
    (list-ref scores 0))
  (define (score-ethel scores)
    (list-ref scores 1))
  (define (score-joan scores)
    (list-ref scores 2))
  (define (score-kitty scores)
    (list-ref scores 3))
  (define (score-mary scores)
    (list-ref scores 4))
  (define restriction
    (combine-predicates-and
     (list distinct?
           (either (lambda (scores) (= (score-kitty scores) 2))
                   (lambda (scores) (= (score-betty scores) 3)))
           (either (lambda (scores) (= (score-ethel scores) 1))
                   (lambda (scores) (= (score-joan scores) 2)))
           (either (lambda (scores) (= (score-joan scores) 3))
                   (lambda (scores) (= (score-ethel scores) 5)))
           (either (lambda (scores) (= (score-kitty scores) 2))
                   (lambda (scores) (= (score-mary scores) 4)))
           (either (lambda (scores) (= (score-mary scores) 4))
                   (lambda (scores) (= (score-betty scores) 1))))))
  (define values '(1 2 3 4 5))
  (filter restriction
          (cartesian-product
           (list values
                 values
                 values
                 values
                 values))))
\end{lstlisting}

It turns out that the five kids are respectively the third, fifth, second, first and fourth.

\section{Exercise 4.43}

My first Scheme solution:

\begin{lstlisting}
(define (generate-circular-pairs-from-list items)
  (define (helper-iter items first-item)
    (if (null? (cdr items))
        (list (cons (car items)
                    first-item))
        (cons (cons (car items)
                    (cadr items))
              (helper-iter (cdr items) first-item))))
  (helper-iter items (car items)))

(define (create-predicate-with-precondition precondition
                                            predicate
                                            default)
  (lambda (foo)
    (if (precondition foo)
        (predicate foo)
        default)))

(define (combine-predicates-and predicates)
  (cond [(null? predicates)
         (error "No predicates provided")]
        [(null? (cdr predicates))
         (car predicates)]
        [else (lambda (foo)
                (if ((car predicates) foo)
                    ((combine-predicates-and (cdr predicates)) foo)
                    #f))]))

(define (apply-predicate-to-all predicate)
  (define (apply-helper items)
    (cond [(null? items) #t]
          [(predicate (car items))
           (apply-helper (cdr items))]
          [else #f]))
  apply-helper)

(define (member-of? equal-op item items)
  (cond [(null? items) #f]
        [(equal-op item
                   (car items)) #t]
        [else (member-of? equal-op
                          item
                          (cdr items))]))

(define (distinct? equal-op items)
  (cond [(null? items) #t]
        [(null? (cdr items)) #t]
        [(member-of? equal-op
                     (car items)
                     (cdr items)) #f]
        [else (distinct? equal-op
                         (cdr items))]))

(define (cartesian-product variables)
  (cond [(null? variables)
         (error "No variables provided")]
        [(null? (cdr variables))
         (map (lambda (value)
                (list value))
              (car variables))]
        [else
         (let* ([first-var (car variables)]
                [rest-product (cartesian-product (cdr variables))])
           (foldr append
                  '()
                  (map (lambda (value)
                         (map (lambda (comb)
                                (cons value comb))
                              rest-product))
                       first-var)))]))

(define (list-of-n-items item n)
  (if (= n 0)
      '()
      (cons item (list-of-n-items item
                                  (- n 1)))))

(define (generate-all-arrangements items)
  (filter (lambda (sequence)
            (distinct? equal? sequence))
          (cartesian-product
           (list-of-n-items items
                            (length items)))))

(define (yacht-puzzle)
  (define father-names
    (list "moore" "downing" "hall" "barnacle" "parker"))
  (define daughter-names
    (list "mary" "gabrielle" "lorna" "rosalind" "melissa"))
  (define father-name-arrangements
    (generate-all-arrangements father-names))
  (define daughter-name-arrangements
    (generate-all-arrangements daughter-names))
  (define name-combinations
    (map (lambda (father-and-daughter-names)
           (map cons
                (car father-and-daughter-names)
                (cadr father-and-daughter-names)))
         (cartesian-product (list father-name-arrangements
                                  daughter-name-arrangements))))
  (define from-father caar)
  (define from-daughter cdar)
  (define to-father cadr)
  (define to-daughter cddr)
  (define links-restriction
    (apply-predicate-to-all
     (combine-predicates-and
      (list (create-predicate-with-precondition
             (lambda (link)
               (equal? (from-father link)
                       "moore"))
             (lambda (link)
               (and (equal? (from-daughter link)
                            "mary")
                    (equal? (to-daughter link)
                            "lorna")))
             #t)
            (create-predicate-with-precondition
             (lambda (link)
               (equal? (from-father link)
                       "barnacle"))
             (lambda (link)
               (and (equal? (from-daughter link)
                            "melissa")
                    (equal? (to-daughter link)
                            "gabrielle")))
             #t)
            (create-predicate-with-precondition
             (lambda (link)
               (equal? (from-father link)
                       "hall"))
             (lambda (link)
               (equal? (to-daughter link)
                       "rosalind"))
             #t)
            (create-predicate-with-precondition
             (lambda (link)
               (equal? (from-father link)
                       "downing"))
             (lambda (link)
               (equal? (to-father link)
                       "barnacle"))
             #t)
            (create-predicate-with-precondition
             (lambda (link)
               (equal? (from-daughter link)
                       "gabrielle"))
             (lambda (link)
               (equal? (to-father link)
                       "parker"))
             #t)))))
                            
  (filter
   (lambda (combination)
     (let ([links (generate-circular-pairs-from-list combination)])
       (links-restriction links)))
   name-combinations))
\end{lstlisting}

This version is long, inefficient and defective. It assumes that the yachts' names form a single circle, while the names can actually form more than one circles. Also, it considers a lot of redundant cases, where one can be derived from other using cyclic shifts. Such redundancy results in both inefficiency and redundant answers.

Now let's improve the solution. Firstly the representation of relations can be greatly simplified as follows:

\begin{lstlisting}
(define (barnacle-daughter yachts)
  (car (list-ref yachts 0)))
(define (barnacle-yacht yachts)
  (cdr (list-ref yachts 0)))
(define (moore-daughter yachts)
  (car (list-ref yachts 1)))
(define (moore-yacht yachts)
  (cdr (list-ref yachts 1)))
(define (hall-daughter yachts)
  (car (list-ref yachts 2)))
(define (hall-yacht yachts)
  (cdr (list-ref yachts 2)))
(define (downing-daughter yachts)
  (car (list-ref yachts 3)))
(define (downing-yacht yachts)
  (cdr (list-ref yachts 3)))
(define (parker-daughter yachts)
  (car (list-ref yachts 4)))
(define (parker-yacht yachts)
  (cdr (list-ref yachts 4)))
\end{lstlisting}

Also, the algorithm of generating all permutations can also be improved as follows:

\begin{lstlisting}
(define (permutations lst)
  (if (null? lst)
      (list lst)
      (mapinsert (car lst)
                 (permutations (cdr lst)))))
(define (mapinsert elem ps)
  (if (null? ps)
      '()
      (insert elem
              (car ps)
              (car ps)
              (mapinsert elem
                         (cdr ps)))))
(define (insert elem p1 p2 ps)
  (if (null? p2)
      (cons (put elem
                 p1
                 p2)
            ps)
      (cons (put elem
                 p1
                 p2)
            (insert elem
                    p1
                    (cdr p2)
                    ps))))
(define (put elem p1 p2)
  ; result: [element in p1 not in p2]::[elem]::[p2]
  (if (eq? p1 p2)
      (cons elem p2)
      (cons (car p1)
            (put elem
                 (cdr p1)
                 p2))))
\end{lstlisting}

Now we can generate all cases:

\begin{lstlisting}
(define all-cases
  (let ([names '(gabrielle lorna rosalind melissa mary)])
    (map (lambda (perm)
           (map cons
                perm
                names))
         (permutations names))))
\end{lstlisting}

Then let's take a look at restrictions:

\begin{lstlisting}
(define restriction
  (lambda (yachts)
    (and (eq? (barnacle-daughter yachts)
              'melissa)
         (eq? (moore-daughter yachts)
              'mary)
         (not (eq? (hall-daughter yachts)
                   'rosalind))
         (eq? (daughter-with-yacht-name-as (parker-daughter yachts)
                                           yachts)
              'gabrielle))))
\end{lstlisting}

Altogether:

\begin{lstlisting}
(define (barnacle-daughter yachts)
  (car (list-ref yachts 0)))
(define (barnacle-yacht yachts)
  (cadr (list-ref yachts 0)))
(define (moore-daughter yachts)
  (car (list-ref yachts 1)))
(define (moore-yacht yachts)
  (cadr (list-ref yachts 1)))
(define (hall-daughter yachts)
  (car (list-ref yachts 2)))
(define (hall-yacht yachts)
  (cadr (list-ref yachts 2)))
(define (downing-daughter yachts)
  (car (list-ref yachts 3)))
(define (downing-yacht yachts)
  (cadr (list-ref yachts 3)))
(define (parker-daughter yachts)
  (car (list-ref yachts 4)))
(define (parker-yacht yachts)
  (cadr (list-ref yachts 4)))
(define (daughter-with-yacht-name-as name yachts)
  (car (assoc name yachts)))

(define (permutations lst)
  (define (mapinsert elem ps)
    (if (null? ps)
        '()
        (insert elem
                (car ps)
                (car ps)
                (mapinsert elem
                           (cdr ps)))))
  (define (insert elem p1 p2 ps)
    (if (null? p2)
        (cons (put elem
                   p1
                   p2)
              ps)
        (cons (put elem
                   p1
                   p2)
              (insert elem
                      p1
                      (cdr p2)
                      ps))))
  (define (put elem p1 p2)
    ; result: [element in p1 not in p2]::[elem]::[p2]
    (if (eq? p1 p2)
        (cons elem p2)
        (cons (car p1)
              (put elem
                   (cdr p1)
                   p2))))
  (if (null? lst)
      (list lst)
      (mapinsert (car lst)
                 (permutations (cdr lst)))))

(define (yachts-puzzle)
  (define all-cases
    (let ([names '(gabrielle lorna rosalind melissa mary)])
      (map (lambda (perm)
             (map list
                  perm
                  names))
           (permutations names))))
  (define restriction
    (lambda (yachts)
      (and (eq? (barnacle-daughter yachts)
                'melissa)
           (eq? (moore-daughter yachts)
                'mary)
           (not (eq? (hall-daughter yachts)
                     'rosalind))
           (eq? (daughter-with-yacht-name-as (parker-daughter yachts)
                                             yachts)
                'gabrielle))))
  (filter restriction
          all-cases))
\end{lstlisting}

Much better :)

Here's an solution using \lstinline{amb} from \url{http://community.schemewiki.org/?sicp-ex-4.43}:

\begin{lstlisting}
(define (yacht) 
  (define gab 'gabrielle) 
  (define lor 'lorna) 
  (define ros 'rosalind) 
  (define mel 'melissa) 
  (define mar 'mary-ann) 
  (let ((barnacle (amb gab lor ros mel mar))) 
    (require (eq? barnacle mel)) 
    (let ((moore (amb gab lor ros mel mar))) 
      (require (eq? moore mar))     
      (let ((hall (amb gab lor ros mel mar))) 
        (require (not (memq hall (list barnacle moore ros))))  
        (let ((downing (amb gab lor ros mel mar))) 
          (require (not (memq downing (list barnacle moore hall mel)))) 
          (let ((parker (amb gab lor ros mel mar))) 
            (require (not (memq parker 
                                (list barnacle moore hall downing mar)))) 
            (let ((yacht-names 
                   (list (list barnacle gab) 
                         (list moore lor) 
                         (list hall ros) 
                         (list downing mel) 
                         (list parker mar)))) 
              (require (eq? parker (cadr (assq gab yacht-names)))) 
              (list (list 'barnacle barnacle) 
                    (list 'moore moore) 
                    (list 'hall hall) 
                    (list 'downing downing) 
                    (list 'parker parker)))))))))
\end{lstlisting}

If not given the restriction that Mary's last name is Moore, the restrictions would be like:

\begin{lstlisting}
(define restriction
  (lambda (yachts)
    (and (eq? (barnacle-daughter yachts)
              'melissa)
         (not (eq? (moore-daughter yachts)
                   'lorna))
         (not (eq? (hall-daughter yachts)
                   'rosalind))
         (eq? (daughter-with-yacht-name-as (parker-daughter yachts)
                                           yachts)
              'gabrielle))))
\end{lstlisting}

Result:

\begin{lstlisting}
(((melissa gabrielle)
  (rosalind lorna)
  (lorna rosalind)
  (mary melissa)
  (gabrielle mary))
 ((melissa gabrielle)
  (rosalind lorna)
  (mary rosalind)
  (lorna melissa)
  (gabrielle mary))
 ((melissa gabrielle)
  (mary lorna)
  (lorna rosalind)
  (rosalind melissa)
  (gabrielle mary)))
\end{lstlisting}

\section{Exercise 4.44}

A Racket solution:

\begin{lstlisting}
#lang racket

(require racket/set)

(define (permutations lst)
  (define (mapinsert elem ps)
    (if (null? ps)
        '()
        (insert elem
                (car ps)
                (car ps)
                (mapinsert elem
                           (cdr ps)))))
  (define (insert elem p1 p2 ps)
    (if (null? p2)
        (cons (put elem
                   p1
                   p2)
              ps)
        (cons (put elem
                   p1
                   p2)
              (insert elem
                      p1
                      (cdr p2)
                      ps))))
  (define (put elem p1 p2)
    ; result: [element in p1 not in p2]::[elem]::[p2]
    (if (eq? p1 p2)
        (cons elem p2)
        (cons (car p1)
              (put elem
                   (cdr p1)
                   p2))))
  (if (null? lst)
      (list lst)
      (mapinsert (car lst)
                 (permutations (cdr lst)))))

(define (range low high)
  (if (> low high)
      '()
      (cons low
            (range (+ low 1)
                   high))))

(define (distinct? elems)
  (= (length elems)
     (set-count (list->set elems))))

(define (enumerate elems)
  (define (helper elems i)
    (if (null? elems)
        '()
        (cons (cons i
                    (car elems))
              (helper (cdr elems)
                      (+ i 1)))))
  (helper elems 0))

(define (queens n)
  (define (row-plus-col cols)
    (map (lambda (row-and-col)
           (+ (car row-and-col)
              (cdr row-and-col)))
         (enumerate cols)))
  (define (row-minus-col cols)
    (map (lambda (row-and-col)
           (- (car row-and-col)
              (cdr row-and-col)))
         (enumerate cols)))
  (define candidates
    (permutations (range 0
                         (- n 1))))
  (filter (lambda (candidate)
            (and (distinct? (row-plus-col candidate))
                 (distinct? (row-minus-col candidate))))
          candidates))
\end{lstlisting}

A nondeterministic solution:

\begin{lstlisting}
(define (queens)
  (define (make-queens n)
    (if (= n 0)
        '()
        (cons (amb 0 1 2 3 4 5 6 7)
              (make-queens (- n 1)))))
  (let ((queens (make-queens 8)))
    (require (distinct? queens))
    (require (distinct? (row-plus-col queens)))
    (require (distinct? (row-minus-col queens)))
    queens))
\end{lstlisting}

\section{Exercise 4.45}

\subsection{a.}

The professor lectures to the student.
The professor lectures in the class.
The professor lectures with the cat.

\begin{lstlisting}
- professor
  - lectures
    - to student
    - in class
    - with cat
\end{lstlisting}

\subsection{b.}

The professor lectures to the student.
The professor lectures in the class.
The cat's in the class.

\begin{lstlisting}
- professor
  - lectures
    - to student
    - in class
         - with cat
\end{lstlisting}

\subsection{c.}

The professor lectures to the student.
The student's in the class.
The professor lectures with the cat.

\begin{lstlisting}
- professor
  - lectures
    - to student
         - in class
    - with cat
\end{lstlisting}

\subsection{d.}

The professor lectures to the student.
The student's in the class.
The student's with the cat.

\begin{lstlisting}
- professor
  - lectures
    - to student
         - in class
         - with cat
\end{lstlisting}

\subsection{e.}

The professor lectures to the student.
The student's in the class.
The cat's in the class.

\begin{lstlisting}
- professor
  - lectures
    - to student
         - in class
              - with cat
\end{lstlisting}

\section{Exercise 4.46}

Because \lstinline{parse*} procedures have side effects. In \lstinline{parse-sentence} we rely on the left-to-right evaluation order so that a noun phrase get parsed (as the input get consumed) before a verb phrase does. And of course, we can use nested \lstinline{let}s to explicitly specify such order.

\section{Exercise 4.47}

It won't work, because the corresponding grammar is left recursive:

\begin{lstlisting}
VerbPhrase :=
  VerbPhrase PrepPhrase
| Verb
\end{lstlisting}

The result of this is that the recursive calls can go infinitely deep by always expanding a term to itself and never proceeding a bit on input.

To eliminate left recursion, we can modify the grammar as follows:

\begin{lstlisting}
VerbPhrase :=
  Verb OptPreps
OptPreps :=
  PrepPhrase OptPreps
| Empty
\end{lstlisting}

Which happens to be exactly what the original version is doing:

\begin{lstlisting}
(define (parse-verb-phrase)
  (define (maybe-extend verb-phrase)
    (amb verb-phrase
         (maybe-extend (list ’verb-phrase
                             verb-phrase
                             (parse-prepositional-phrase)))))
  (maybe-extend (parse-word verbs)))
\end{lstlisting}

If we interchange the order of expressions in the \lstinline{amb}, infinite recursive calls of \lstinline{parse-verb-phrase} occur immediately.

\section{Exercise 4.48}

The grammar with adjectives:

\begin{lstlisting}
NounPhrase :=
  SimpleNounPhrase OptPreps
SimpleNounPhrase :=
  Article Adjective Noun
| Article Noun
\end{lstlisting}

The parsing procedure:

\begin{lstlisting}
(define (parse-simple-noun-phrase)
  (amb (list 'simple-noun-phrase-with-adj
             (parse-word articles)
             (parse-word adjectives)
             (parse-word nouns))
       (list 'simple-noun-phrase
             (parse-word articles)
             (parse-word nouns))))
\end{lstlisting}

It's quite amazing that the structure of the grammar and that of the parsing procedure are very much alike. A slight modification to the grammar corresponds intuitively to a slight modification to the parsing procedure. It's reminiscent of the idea in the book \textit{Hackers and Painters} that the program itself should reflect only the problem it aims to solve, and that any additional form where the programmer acts as an compiler is a signal of inadequency of abstraction.

\section{Exercise 4.49}

Code:

\begin{lstlisting}
(define (an-element-of elements)
  (if (null? elements)
      (amb)
      (amb (car elements)
           (an-element-of (cdr elements)))))
(define (parse-word vocabulary)
  (require (not (null? *unparsed*)))
  (let ((found-word (an-element-of vocabulary)))
    (set! *unparsed* (cdr *unparsed*))
    (list (car word-list) found-word)))
\end{lstlisting}

\section{Exercise 4.50}

One approach is to shuffle choices when analyzing:

\begin{lstlisting}
...
(let ((cprocs (map analyze (shuffle (amb-choices exp)))))
...
\end{lstlisting}

So that alternatives are randomized at compile time and rest of the analyzing procedure remains the same.

\section{Exercise 4.51}

Code:

\begin{lstlisting}
(define (analyze-permanent-assignment exp)
  (let ((var (assignment-variable exp))
        (analyzed-value-exp (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (analyzed-value-exp env
                          (lambda (val fail2)
                            (succeed (set-variable-value! var
                                                          val
                                                          env)
                                     fail2))
                          fail))))
\end{lstlisting}

If we had used \lstinline{set!} instead of \lstinline{permanent-set!}, every number followed by combinations of \lstinline{x} and \lstinline{y} would be 1.

\section{Exercise 4.52}

Code:

\begin{lstlisting}
(define (analyze-if-fail exp)
  (let ((default (analyze (if-fail-default exp)))
        (alter (analyze (if-fail-alter exp))))
    (lambda (env succeed fail)
      (default env
               (lambda (default-value fail2)
                 (succeed default-value fail2))
               (lambda ()
                 (alter env
                        (lambda (alter-value fail3)
                          (succeed alter-value fail3))
                        fail))))))
\end{lstlisting}













\end{document}
