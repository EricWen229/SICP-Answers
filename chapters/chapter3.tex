\documentclass[../main.tex]{subfiles}

\begin{document}

\section{Exercise 3.1}

Code:

\begin{lstlisting}
(define (make-accumulator sum)
  (lambda (x)
    (begin (set! sum (+ sum x))
           sum))))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define acc-5 (make-accumulator 5))
(acc-5 1) ; 6 expected
(acc-5 2) ; 8 expected
(acc-5 3) ; 11 expected
(acc-5 4) ; 15 expected
(acc-5 -15) ; 0 expected
(define acc-neg-1 (make-accumulator -1))
(acc-neg-1 11) ; 10 expected
\end{lstlisting}

Result:

\begin{lstlisting}
6  ; pass
8  ; pass
11 ; pass
15 ; pass
0  ; pass
10 ; pass
\end{lstlisting}

\section{Exercise 3.2}

Code:

\begin{lstlisting}
(define (make-monitored proc)
  (let ((count 0))
    (define (dispatch . args)
      (cond ((equal? args '(how-many-calls?)) count)
            ((equal? args '(reset-count))
             (begin (set! count 0)
                    'ok))
            (else (begin (set! count (+ 1 count))
                         (apply proc args)))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define s (make-monitored sqrt))
(s 'how-many-calls?) ; 0 expected
(s 100)              ; 10 expected
(s 49)               ; 7 expected
(s 1)                ; 1 expected
(s 0)                ; 0 expected
(s 'how-many-calls?) ; 4 expected
(s 'reset-count)     ; ok expected
(s 'how-many-calls?) ; 0 expected
(s 144)              ; 12 expected
(s 64)               ; 8 expected
(s 4)                ; 2 expected
(s 0)                ; 0 expected
(s 'how-many-calls?) ; 4 expected
\end{lstlisting}

Result:

\begin{lstlisting}
;; s defined
0  ; pass
10 ; pass
7  ; pass
1  ; pass
0  ; pass
4  ; pass
ok ; pass
0  ; pass
12 ; pass
8  ; pass
2  ; pass
0  ; pass
4  ; pass
\end{lstlisting}

\section{Exercise 3.3}

Code:

\begin{lstlisting}
(define (make-account balance password)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
               "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch pwd m)
    (cond ((not (eq? pwd password))
           (lambda args "Incorrect password"))
          ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (lambda args "Unknown method"))))
  dispatch)
\end{lstlisting}

Tests:

\begin{lstlisting}
(define my-account (make-account 100 'take-that))
((my-account 'take-that 'withdraw) 50) ; 50 expected
((my-account 'take-that 'deposit) 30)  ; 80 expected
((my-account 'take-this 'withdraw) 80) ; error expected
((my-account 'take-that 'withdraw) 80) ; 0 expected
\end{lstlisting}

Results:

\begin{lstlisting}
;; my-account defined
50                   ; pass
80                   ; pass
"Incorrect password" ; pass
0                    ; pass
\end{lstlisting}

\section{Exercise 3.4}

Code:

\begin{lstlisting}
(define (call-the-cops)
  "Hey you b**stard!")
(define (make-account balance password)
  (let ((error-count 0))
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (error . args)
      (if (< error-count 7)
          (begin (set! error-count (+ error-count 1))
                 "Incorrect password")
          (call-the-cops)))
    (define (dispatch pwd m)
      (if (not (eq? pwd password))
          error
          (begin (set! error-count 0)
                 (cond ((eq? m 'withdraw) withdraw)
                       ((eq? m 'deposit) deposit)
                       (else (lambda args "Unknown method"))))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define my-account (make-account 100 'take-that))
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; cops expected
((my-account 'take-that 'withdraw) 50) ; 50 expected
\end{lstlisting}

Result:

\begin{lstlisting}
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Hey you b**stard!"  ; pass
50                   ; pass
\end{lstlisting}

\section{Exercise 3.5}

Code:

\begin{lstlisting}
(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (/ (+ 0.0 trials-passed) trials))
          ((experiment)
           (iter (- trials-remaining 1) (+ trials-passed 1)))
          (else
           (iter (- trials-remaining 1) trials-passed))))
  (iter trials 0))
(define (estimate-integral P xl xu yl yu trials)
  (define (rand-range lower upper)
    (+ lower (random (- upper lower))))
  (define (experiment)
    (let ((x (rand-range xl xu))
          (y (rand-range yl yu)))
      (P x y)))
  (monte-carlo trials experiment))
\end{lstlisting}

Tests (same test for 5 times):

\begin{lstlisting}
(* 4
   (estimate-integral
     (lambda (x y)
       (< (+ (* x x) (* y y)) 1))
     -1.0 1.0 -1.0 1.0 100000)) ;; 3.14159 expected
\end{lstlisting}

Result:

\begin{lstlisting}
3.14116 ; pass
3.15324 ; pass
3.13736 ; pass
3.132   ; pass
3.14752 ; pass
\end{lstlisting}

\section{Exercise 3.6}

To test the code, a pseudo \lstinline{rand-update}
 procedure and a constant initial seed are used.

Code:

\begin{lstlisting}
(define rand
  (let ((x 2333))
    (define (rand-update x)
      (+ x 1))
    (define (generate)
      (set! x (rand-update x))
      x)
    (define (reset value)
      (set! x value)
      'ok)
    (define (dispatch method)
      (cond ((eq? method 'generate) (generate))
            ((eq? method 'reset) reset)
            (else (lambda args "Unknown method"))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
((rand 'reset) 0) ; ok expected
(rand 'generate)  ; 1 expected
(rand 'generate)  ; 2 expected
(rand 'generate)  ; 3 expected
((rand 'reset) 0) ; ok expected
(rand 'generate)  ; 1 expected
(rand 'generate)  ; 2 expected
(rand 'generate)  ; 3 expected
\end{lstlisting}

Result:

\begin{lstlisting}
ok ; pass
1  ; pass
2  ; pass
3  ; pass
ok ; pass
1  ; pass
2  ; pass
3  ; pass
\end{lstlisting}

\section{Exercise 3.7}

Code:

\begin{lstlisting}
;; original account definition
(define (make-account balance password)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch pwd m)
    (cond ((not (eq? pwd password))
           (lambda (amount) "Incorrect password"))
          ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (lambda args "Unknown method"))))
  dispatch)

;; joint account definition
(define (make-joint account password new-password)
  (define (withdraw amount)
    ((account password 'withdraw) amount))
  (define (deposit amount)
    ((account password 'deposit) amount))
  (define (dispatch pwd m)
    (cond ((not (eq? pwd new-password))
           (lambda (amount) "Incorrect password"))
          ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (lambda args "Unknown method"))))
  dispatch)
\end{lstlisting}

Tests:

\begin{lstlisting}
(define peter-acc (make-account 100 'peter))
(define paul-acc (make-joint peter-acc 'peter 'paul))
((paul-acc 'paul 'withdraw) 50) ; 50 expected
((peter-acc 'peter 'deposit) 100) ; 150 expected
((paul-acc 'paul 'withdraw) 0) ; 150 expected
((paul-acc 'peter 'withdraw) 0) ; error expected
\end{lstlisting}

Result:

\begin{lstlisting}
;; peter-acc defined
;; paul-acc defined
50  ; pass
150 ; pass
150 ; pass
"Incorrect password" ; pass
\end{lstlisting}

\section{Exercise 3.8}

Code:

\begin{lstlisting}
(define f
  (let ((multiplier 2))
    (lambda (x)
      (begin (set! multiplier (- multiplier 1))
             (* multiplier x)))))
\end{lstlisting}

\section{Exercise 3.9}

Recursive version:

\begin{lstlisting}
+-----------+
| factorial |<- global env
+-----------+
^    ^      ^
|    |      |
+---++---+  +---+
|n:6||n:5|..|n:1|
+---++---+  +---+
\end{lstlisting}

Iterative version:

\begin{lstlisting}
+-----------+
| factorial |<- global env
+-----------+
^    ^^^
|    |||..
+---++-----------+
|n:6||product:1  |
+---+|counter:1  |
     |max-count:6|
     +-----------+
      ||
     +-----------+
     |product:1  |
     |counter:2  |
     |max-count:6|
     +-----------+
       |
     +-----------+
     |product:2  |
     |counter:3  |
     |max-count:6|
     +-----------+
       ...
\end{lstlisting}

\section{Exercise 3.10}

Implicit local state version:

\begin{lstlisting}
(define W1 (make-withdraw 100))

+-----------------+
| make-withdraw:..|
| W1              |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |     +------------------+
  |     |initial-amount:100|
  |     +------------------+
  |              ^
  |              |
  v        +-----------+
  [+][+]-->|balance:100|
  |        +-----------+
  v
  code


(W1 50)

+----------------+
|make-withdraw:..|
|W1              |
| |              |
+-+--------------+
  |              ^
  |              |
  |     +------------------+
  |     |initial-amount:100|
  |     +------------------+
  |              ^
  |              |
  v        +----------+
  [+][+]-->|balance:50|
  |        +----------+
  v              ^
  code           |
           +-----------+
           | amount:50 |
           +-----------+


(define W2 (make-withdraw 100))

+---------------------------------------+
| make-withdraw:..                      |
| W2 ------------------------+          |<- global env
| W1                         |          |
| |                          |          |
+-+--------------------------+----------+
  |              ^           |          ^
  |              |           |          |
  |     +------------------+ | +------------------+
  |     |initial-amount:100| | |initial-amount:100|
  |     +------------------+ | +------------------+
  |              ^           v          ^
  |              |        [+][+]        |
  v        +----------+    |  |   +-----------+
  [+][+]-->|balance:50|    |  +-->|balance:100|
  |        +----------+    |      +-----------+
  v                        |
  code <-------------------+
\end{lstlisting}

Explicit local state version:

\begin{lstlisting}
(define W1 (make-withdraw 100))

+-----------------+
| make-withdraw:..|
| W1              |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |        +-----------+
  [+][+]-->|balance:100|
  |        +-----------+
  v
  code


(W1 50)

+----------------+
|make-withdraw:..|
|W1              |
| |              |
+-+--------------+
  |              ^
  |              |
  v        +----------+
  [+][+]-->|balance:50|
  |        +----------+
  v
  code


(define W2 (make-withdraw 100))
+---------------------------------------+
| make-withdraw:..                      |
| W2 ------------------------+          |<- global env
| W1                         |          |
| |                          |          |
+-+--------------------------+----------+
  |              ^           v          ^
  |              |        [+][+]        |
  v        +----------+    |  |   +-----------+
  [+][+]-->|balance:50|    |  +-->|balance:100|
  |        +----------+    |      +-----------+
  v                        |
  code <-------------------+
\end{lstlisting}

They act similarly except that in the former one
 redundant frame is created and never used
 by each account.
 
\section{Exercise 3.11}

The process is as follows:

\begin{lstlisting}
(define acc (make-account 50))

+-----------------+
| make-account:.. |
| acc             |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |     +--------------+
  |     | balance:50   |
  |     | withdraw:... |
  |     | deposit:...  |
  |  +--+ dispatch     |
  |  |  +--------------+
  |  |           ^
  v  v           |
  [+][+]---------+
  |
  v
  code of dispatch

((acc 'deposit) 40)

+-----------------+
| make-account:.. |
| acc             |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |     +--------------+. +----------+
  |     | balance:90   |<-|m:'deposit|
  |     | withdraw:... |  +----------+
  |     | deposit:...  |  +---------+
  |  +--+ dispatch     |<-|amount:40|
  |  |  +--------------+  +---------+
  |  |           ^
  v  v           |
  [+][+]---------+
  |
  v
  code of dispatch

((acc 'withdraw) 60)

+-----------------+
| make-account:.. |
| acc             |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |     +--------------+. +-----------+
  |     | balance:30   |<-|m:'withdraw|
  |     | withdraw:... |  +-----------+
  |     | deposit:...  |  +---------+
  |  +--+ dispatch     |<-|amount:60|
  |  |  +--------------+  +---------+
  |  |           ^
  v  v           |
  [+][+]---------+
  |
  v
  code of dispatch

(define acc2 (make-account 100))

+-----------------+
| make-account:.. |<- global env
| acc2 -----------+------+
| acc             |      |
| |               |<-----+--+
+-+---------------+      |  |
  |              ^       |  |
  |              |       |  |
  |     +--------------+ | +--------------+
  |     | balance:30   | | | balance:100  |
  |     | withdraw:... | | | withdraw:... |
  |     | deposit:...  | | | deposit:...  |
  |  +--+ dispatch     | | | dispatch     |
  |  |  +--------------+ | +---+----------+
  |  |           ^       |     | ^
  v  v           |       v<----+ |
  [+][+]---------+  [+][+]-------+
  |                  |
  v                  |
  code of dispatch <-+
\end{lstlisting}

\lstinline{acc} and \lstinline{acc2} share code of
 procedure definitions (implementation dependent).
 
\section{Exercise 3.12}

The process is as follows:

\begin{lstlisting}
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))

x -> [+][+]->[+][x]
      |       |
      v       v
      a       b

y -> [+][+]->[+][x]
      |       |
      v       v
      c       d

z -> [+][+]->[+][+]->[+][+]->[+][x]
      |       |       |       |
      v       v       v       v
      a       b       c       d

(cdr x) ; returns (b)
(define w (append! x y))

      w
      |
      v
x -> [+][+]->[+][+]
      |       |  |
      v       v  |
      a       b  |
                 |
      +----------+
      |
      v
y -> [+][+]->[+][x]
      |       |
      v       v
      c       d

(cdr x) ; returns (b c d)
\end{lstlisting}

\section{Exercise 3.13}

The structure is as follows:

\begin{lstlisting}
      +------------------+
      |                  |
      v                  |
z -> [+][+]->[+][+]->[+][+]
      |       |       |
      v       v       v
      a       b       c
\end{lstlisting}

Evaluating \lstinline{(last-pair z)}
 creates an infinite loop.

\section{Exercise 3.14}

\lstinline{mystery} reverses the given list
 \lstinline{x} and returns the reversed list.

The structures of \lstinline{v} and \lstinline{w}
 are as follows:

\begin{lstlisting}
                              v
                              |
                              v
w -> [+][+]->[+][+]->[+][+]->[+][x]
      |       |       |       |
      v       v       v       v
      d       c       b       a
\end{lstlisting}

The value of \lstinline{w} is \lstinline{(d c b a)},
 and the value of \lstinline{v} is \lstinline{(a)}.

\section{Exercise 3.15}

\begin{lstlisting}
z1 -> [+][+]
       |  |
       v  v
x  -> [+][+]->[+][x]
       |       |
       v       v
       wow     b

z2 -> [+][+]->[+][+]->[+][x]
       |       |       |
       |       v       v
       |       a       b
       |               ^
       |               |
       +------[+][+]->[+][x]
               |
               v
               wow
\end{lstlisting}

\section{Exercise 3.16}

\begin{lstlisting}
x1 -> [x][+]->[x][+]->[+][x]

x2 -> [+][+]->[+][x]
       |       |
       +--+  +-+
          |  |
          v  v
         [x][x]

x3 -> [+][+]->[+][+]->[x][x]
       |     ^ |     ^
       |     | |     |
       +-----+ +-----+

x4 -> [+][+]->[x][+]->[+][x]
     ^ |
     | |
     +-+
\end{lstlisting}

Code:

\begin{lstlisting}
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))

(define x1 '(() () ()))
(define x2
  (let ((common-pair (cons () ())))
   (list common-pair common-pair)))
(define x3
  (let ((inner-pair (cons () ())))
    (let ((middle-pair (cons inner-pair inner-pair)))
      (let ((outer-pair (cons middle-pair middle-pair)))
        outer-pair))))
(define x4
  (let ((l '(() () ())))
    (set-car! l l)
    l))
\end{lstlisting}

Tests:

\begin{lstlisting}
(count-pairs x1) ; 3 expected
(count-pairs x2) ; 4 expected
(count-pairs x3) ; 7 expected
(count-pairs x4) ; infinite recursive calls expected
\end{lstlisting}

Result:

\begin{lstlisting}
3 ; pass
4 ; pass
7 ; pass
;; maximum recursion depth exceeded, pass
\end{lstlisting}

\section{Exercise 3.17}

Code:

\begin{lstlisting}
(define (count-pairs x)
  (let ((seen-pair-list '()))
    (define (has-seen pair)
      (define (is-in-list pair pair-list)
        (if (null? pair-list)
            #f
            (if (eq? pair (car pair-list))
                #t
                (is-in-list pair (cdr pair-list)))))
      (is-in-list pair seen-pair-list))
    (define (mark-as-seen pair)
      (set! seen-pair-list (cons pair seen-pair-list)))
    (define (count-pairs-recur x)
      (cond ((not (pair? x)) 0)
            ((has-seen x) 0)
            (else
              (begin (mark-as-seen x)
                     (+ (count-pairs-recur (car x))
                        (count-pairs-recur (cdr x))
                        1)))))
    (count-pairs-recur x)))

(define x1 '(() () ()))
(define x2
  (let ((common-pair (cons () ())))
   (list common-pair common-pair)))
(define x3
  (let ((inner-pair (cons () ())))
    (let ((middle-pair (cons inner-pair inner-pair)))
      (let ((outer-pair (cons middle-pair middle-pair)))
        outer-pair))))
(define x4
  (let ((l '(() () ())))
    (set-car! l l)
    l))
\end{lstlisting}

Tests:

\begin{lstlisting}
(count-pairs x1) ; 3 expected
(count-pairs x2) ; 3 expected
(count-pairs x3) ; 3 expected
(count-pairs x4) ; 3 expected
\end{lstlisting}

Result:

\begin{lstlisting}
3 ; pass
3 ; pass
3 ; pass
3 ; pass
\end{lstlisting}

\end{document}









