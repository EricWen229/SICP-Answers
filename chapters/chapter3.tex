\documentclass[../main.tex]{subfiles}

\begin{document}

\section{Exercise 3.1}

Code:

\begin{lstlisting}
(define (make-accumulator sum)
  (lambda (x)
    (begin (set! sum (+ sum x))
           sum))))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define acc-5 (make-accumulator 5))
(acc-5 1) ; 6 expected
(acc-5 2) ; 8 expected
(acc-5 3) ; 11 expected
(acc-5 4) ; 15 expected
(acc-5 -15) ; 0 expected
(define acc-neg-1 (make-accumulator -1))
(acc-neg-1 11) ; 10 expected
\end{lstlisting}

Result:

\begin{lstlisting}
6  ; pass
8  ; pass
11 ; pass
15 ; pass
0  ; pass
10 ; pass
\end{lstlisting}

\section{Exercise 3.2}

Code:

\begin{lstlisting}
(define (make-monitored proc)
  (let ((count 0))
    (define (dispatch . args)
      (cond ((equal? args '(how-many-calls?)) count)
            ((equal? args '(reset-count))
             (begin (set! count 0)
                    'ok))
            (else (begin (set! count (+ 1 count))
                         (apply proc args)))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define s (make-monitored sqrt))
(s 'how-many-calls?) ; 0 expected
(s 100)              ; 10 expected
(s 49)               ; 7 expected
(s 1)                ; 1 expected
(s 0)                ; 0 expected
(s 'how-many-calls?) ; 4 expected
(s 'reset-count)     ; ok expected
(s 'how-many-calls?) ; 0 expected
(s 144)              ; 12 expected
(s 64)               ; 8 expected
(s 4)                ; 2 expected
(s 0)                ; 0 expected
(s 'how-many-calls?) ; 4 expected
\end{lstlisting}

Result:

\begin{lstlisting}
;; s defined
0  ; pass
10 ; pass
7  ; pass
1  ; pass
0  ; pass
4  ; pass
ok ; pass
0  ; pass
12 ; pass
8  ; pass
2  ; pass
0  ; pass
4  ; pass
\end{lstlisting}

\section{Exercise 3.3}

Code:

\begin{lstlisting}
(define (make-account balance password)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
               "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch pwd m)
    (cond ((not (eq? pwd password))
           (lambda args "Incorrect password"))
          ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (lambda args "Unknown method"))))
  dispatch)
\end{lstlisting}

Tests:

\begin{lstlisting}
(define my-account (make-account 100 'take-that))
((my-account 'take-that 'withdraw) 50) ; 50 expected
((my-account 'take-that 'deposit) 30)  ; 80 expected
((my-account 'take-this 'withdraw) 80) ; error expected
((my-account 'take-that 'withdraw) 80) ; 0 expected
\end{lstlisting}

Results:

\begin{lstlisting}
;; my-account defined
50                   ; pass
80                   ; pass
"Incorrect password" ; pass
0                    ; pass
\end{lstlisting}

\section{Exercise 3.4}

Code:

\begin{lstlisting}
(define (call-the-cops)
  "Hey you b**stard!")
(define (make-account balance password)
  (let ((error-count 0))
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (error . args)
      (if (< error-count 7)
          (begin (set! error-count (+ error-count 1))
                 "Incorrect password")
          (call-the-cops)))
    (define (dispatch pwd m)
      (if (not (eq? pwd password))
          error
          (begin (set! error-count 0)
                 (cond ((eq? m 'withdraw) withdraw)
                       ((eq? m 'deposit) deposit)
                       (else (lambda args "Unknown method"))))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define my-account (make-account 100 'take-that))
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; cops expected
((my-account 'take-that 'withdraw) 50) ; 50 expected
\end{lstlisting}

Result:

\begin{lstlisting}
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Hey you b**stard!"  ; pass
50                   ; pass
\end{lstlisting}

\section{Exercise 3.5}

Code:

\begin{lstlisting}
(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (/ (+ 0.0 trials-passed) trials))
          ((experiment)
           (iter (- trials-remaining 1) (+ trials-passed 1)))
          (else
           (iter (- trials-remaining 1) trials-passed))))
  (iter trials 0))
(define (estimate-integral P xl xu yl yu trials)
  (define (rand-range lower upper)
    (+ lower (random (- upper lower))))
  (define (experiment)
    (let ((x (rand-range xl xu))
          (y (rand-range yl yu)))
      (P x y)))
  (monte-carlo trials experiment))
\end{lstlisting}

Tests (same test for 5 times):

\begin{lstlisting}
(* 4
   (estimate-integral
     (lambda (x y)
       (< (+ (* x x) (* y y)) 1))
     -1.0 1.0 -1.0 1.0 100000)) ;; 3.14159 expected
\end{lstlisting}

Result:

\begin{lstlisting}
3.14116 ; pass
3.15324 ; pass
3.13736 ; pass
3.132   ; pass
3.14752 ; pass
\end{lstlisting}

\section{Exercise 3.6}

To test the code, a pseudo \lstinline{rand-update}
 procedure and a constant initial seed are used.

Code:

\begin{lstlisting}
(define rand
  (let ((x 2333))
    (define (rand-update x)
      (+ x 1))
    (define (generate)
      (set! x (rand-update x))
      x)
    (define (reset value)
      (set! x value)
      'ok)
    (define (dispatch method)
      (cond ((eq? method 'generate) (generate))
            ((eq? method 'reset) reset)
            (else (lambda args "Unknown method"))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
((rand 'reset) 0) ; ok expected
(rand 'generate)  ; 1 expected
(rand 'generate)  ; 2 expected
(rand 'generate)  ; 3 expected
((rand 'reset) 0) ; ok expected
(rand 'generate)  ; 1 expected
(rand 'generate)  ; 2 expected
(rand 'generate)  ; 3 expected
\end{lstlisting}

Result:

\begin{lstlisting}
ok ; pass
1  ; pass
2  ; pass
3  ; pass
ok ; pass
1  ; pass
2  ; pass
3  ; pass
\end{lstlisting}

\section{Exercise 3.7}

Code:

\begin{lstlisting}
;; original account definition
(define (make-account balance password)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch pwd m)
    (cond ((not (eq? pwd password))
           (lambda (amount) "Incorrect password"))
          ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (lambda args "Unknown method"))))
  dispatch)

;; joint account definition
(define (make-joint account password new-password)
  (define (withdraw amount)
    ((account password 'withdraw) amount))
  (define (deposit amount)
    ((account password 'deposit) amount))
  (define (dispatch pwd m)
    (cond ((not (eq? pwd new-password))
           (lambda (amount) "Incorrect password"))
          ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (lambda args "Unknown method"))))
  dispatch)
\end{lstlisting}

Tests:

\begin{lstlisting}
(define peter-acc (make-account 100 'peter))
(define paul-acc (make-joint peter-acc 'peter 'paul))
((paul-acc 'paul 'withdraw) 50) ; 50 expected
((peter-acc 'peter 'deposit) 100) ; 150 expected
((paul-acc 'paul 'withdraw) 0) ; 150 expected
((paul-acc 'peter 'withdraw) 0) ; error expected
\end{lstlisting}

Result:

\begin{lstlisting}
;; peter-acc defined
;; paul-acc defined
50  ; pass
150 ; pass
150 ; pass
"Incorrect password" ; pass
\end{lstlisting}

\section{Exercise 3.8}

Code:

\begin{lstlisting}
(define f
  (let ((multiplier 2))
    (lambda (x)
      (begin (set! multiplier (- multiplier 1))
             (* multiplier x)))))
\end{lstlisting}

\section{Exercise 3.9}

Recursive version:

\begin{lstlisting}
+-----------+
| factorial |<- global env
+-----------+
^    ^      ^
|    |      |
+---++---+  +---+
|n:6||n:5|..|n:1|
+---++---+  +---+
\end{lstlisting}

Iterative version:

\begin{lstlisting}
+-----------+
| factorial |<- global env
+-----------+
^    ^^^
|    |||..
+---++-----------+
|n:6||product:1  |
+---+|counter:1  |
     |max-count:6|
     +-----------+
      ||
     +-----------+
     |product:1  |
     |counter:2  |
     |max-count:6|
     +-----------+
       |
     +-----------+
     |product:2  |
     |counter:3  |
     |max-count:6|
     +-----------+
       ...
\end{lstlisting}

\section{Exercise 3.10}

Implicit local state version:

\begin{lstlisting}
(define W1 (make-withdraw 100))

+-----------------+
| make-withdraw:..|
| W1              |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |     +------------------+
  |     |initial-amount:100|
  |     +------------------+
  |              ^
  |              |
  v        +-----------+
  [+][+]-->|balance:100|
  |        +-----------+
  v
  code


(W1 50)

+----------------+
|make-withdraw:..|
|W1              |
| |              |
+-+--------------+
  |              ^
  |              |
  |     +------------------+
  |     |initial-amount:100|
  |     +------------------+
  |              ^
  |              |
  v        +----------+
  [+][+]-->|balance:50|
  |        +----------+
  v              ^
  code           |
           +-----------+
           | amount:50 |
           +-----------+


(define W2 (make-withdraw 100))

+---------------------------------------+
| make-withdraw:..                      |
| W2 ------------------------+          |<- global env
| W1                         |          |
| |                          |          |
+-+--------------------------+----------+
  |              ^           |          ^
  |              |           |          |
  |     +------------------+ | +------------------+
  |     |initial-amount:100| | |initial-amount:100|
  |     +------------------+ | +------------------+
  |              ^           v          ^
  |              |        [+][+]        |
  v        +----------+    |  |   +-----------+
  [+][+]-->|balance:50|    |  +-->|balance:100|
  |        +----------+    |      +-----------+
  v                        |
  code <-------------------+
\end{lstlisting}

Explicit local state version:

\begin{lstlisting}
(define W1 (make-withdraw 100))

+-----------------+
| make-withdraw:..|
| W1              |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |        +-----------+
  [+][+]-->|balance:100|
  |        +-----------+
  v
  code


(W1 50)

+----------------+
|make-withdraw:..|
|W1              |
| |              |
+-+--------------+
  |              ^
  |              |
  v        +----------+
  [+][+]-->|balance:50|
  |        +----------+
  v
  code


(define W2 (make-withdraw 100))
+---------------------------------------+
| make-withdraw:..                      |
| W2 ------------------------+          |<- global env
| W1                         |          |
| |                          |          |
+-+--------------------------+----------+
  |              ^           v          ^
  |              |        [+][+]        |
  v        +----------+    |  |   +-----------+
  [+][+]-->|balance:50|    |  +-->|balance:100|
  |        +----------+    |      +-----------+
  v                        |
  code <-------------------+
\end{lstlisting}

They act similarly except that in the former one
 redundant frame is created and never used
 by each account.
 
\section{Exercise 3.11}

The process is as follows:

\begin{lstlisting}
(define acc (make-account 50))

+-----------------+
| make-account:.. |
| acc             |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |     +--------------+
  |     | balance:50   |
  |     | withdraw:... |
  |     | deposit:...  |
  |  +--+ dispatch     |
  |  |  +--------------+
  |  |           ^
  v  v           |
  [+][+]---------+
  |
  v
  code of dispatch

((acc 'deposit) 40)

+-----------------+
| make-account:.. |
| acc             |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |     +--------------+. +----------+
  |     | balance:90   |<-|m:'deposit|
  |     | withdraw:... |  +----------+
  |     | deposit:...  |  +---------+
  |  +--+ dispatch     |<-|amount:40|
  |  |  +--------------+  +---------+
  |  |           ^
  v  v           |
  [+][+]---------+
  |
  v
  code of dispatch

((acc 'withdraw) 60)

+-----------------+
| make-account:.. |
| acc             |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |     +--------------+. +-----------+
  |     | balance:30   |<-|m:'withdraw|
  |     | withdraw:... |  +-----------+
  |     | deposit:...  |  +---------+
  |  +--+ dispatch     |<-|amount:60|
  |  |  +--------------+  +---------+
  |  |           ^
  v  v           |
  [+][+]---------+
  |
  v
  code of dispatch

(define acc2 (make-account 100))

+-----------------+
| make-account:.. |<- global env
| acc2 -----------+------+
| acc             |      |
| |               |<-----+--+
+-+---------------+      |  |
  |              ^       |  |
  |              |       |  |
  |     +--------------+ | +--------------+
  |     | balance:30   | | | balance:100  |
  |     | withdraw:... | | | withdraw:... |
  |     | deposit:...  | | | deposit:...  |
  |  +--+ dispatch     | | | dispatch     |
  |  |  +--------------+ | +---+----------+
  |  |           ^       |     | ^
  v  v           |       v<----+ |
  [+][+]---------+  [+][+]-------+
  |                  |
  v                  |
  code of dispatch <-+
\end{lstlisting}

\lstinline{acc} and \lstinline{acc2} share code of
 procedure definitions (implementation dependent).
 
\section{Exercise 3.12}

The process is as follows:

\begin{lstlisting}
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))

x -> [+][+]->[+][x]
      |       |
      v       v
      a       b

y -> [+][+]->[+][x]
      |       |
      v       v
      c       d

z -> [+][+]->[+][+]->[+][+]->[+][x]
      |       |       |       |
      v       v       v       v
      a       b       c       d

(cdr x) ; returns (b)
(define w (append! x y))

      w
      |
      v
x -> [+][+]->[+][+]
      |       |  |
      v       v  |
      a       b  |
                 |
      +----------+
      |
      v
y -> [+][+]->[+][x]
      |       |
      v       v
      c       d

(cdr x) ; returns (b c d)
\end{lstlisting}

\section{Exercise 3.13}

The structure is as follows:

\begin{lstlisting}
      +------------------+
      |                  |
      v                  |
z -> [+][+]->[+][+]->[+][+]
      |       |       |
      v       v       v
      a       b       c
\end{lstlisting}

Evaluating \lstinline{(last-pair z)}
 creates an infinite loop.

\section{Exercise 3.14}

\lstinline{mystery} reverses the given list
 \lstinline{x} and returns the reversed list.

The structures of \lstinline{v} and \lstinline{w}
 are as follows:

\begin{lstlisting}
                              v
                              |
                              v
w -> [+][+]->[+][+]->[+][+]->[+][x]
      |       |       |       |
      v       v       v       v
      d       c       b       a
\end{lstlisting}

The value of \lstinline{w} is \lstinline{(d c b a)},
 and the value of \lstinline{v} is \lstinline{(a)}.

\section{Exercise 3.15}

The structures are as follows:

\begin{lstlisting}
z1 -> [+][+]
       |  |
       v  v
x  -> [+][+]->[+][x]
       |       |
       v       v
       wow     b

z2 -> [+][+]->[+][+]->[+][x]
       |       |       |
       |       v       v
       |       a       b
       |               ^
       |               |
       +------[+][+]->[+][x]
               |
               v
               wow
\end{lstlisting}

\section{Exercise 3.16}

The structures are as follows:

\begin{lstlisting}
x1 -> [x][+]->[x][+]->[+][x]

x2 -> [+][+]->[+][x]
       |       |
       +--+  +-+
          |  |
          v  v
         [x][x]

x3 -> [+][+]->[+][+]->[x][x]
       |     ^ |     ^
       |     | |     |
       +-----+ +-----+

x4 -> [+][+]->[x][+]->[+][x]
     ^ |
     | |
     +-+
\end{lstlisting}

Code:

\begin{lstlisting}
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define x1 '(() () ()))
(define x2
  (let ((common-pair (cons () ())))
   (list common-pair common-pair)))
(define x3
  (let ((inner-pair (cons () ())))
    (let ((middle-pair (cons inner-pair inner-pair)))
      (let ((outer-pair (cons middle-pair middle-pair)))
        outer-pair))))
(define x4
  (let ((l '(() () ())))
    (set-car! l l)
    l))

(count-pairs x1) ; 3 expected
(count-pairs x2) ; 4 expected
(count-pairs x3) ; 7 expected
(count-pairs x4) ; infinite recursive calls expected
\end{lstlisting}

Result:

\begin{lstlisting}
3 ; pass
4 ; pass
7 ; pass
;; maximum recursion depth exceeded, pass
\end{lstlisting}

\section{Exercise 3.17}

Code:

\begin{lstlisting}
(define (count-pairs x)
  (let ((seen-pair-list '()))
    (define (has-seen pair)
      (define (is-in-list pair pair-list)
        (if (null? pair-list)
            #f
            (if (eq? pair (car pair-list))
                #t
                (is-in-list pair (cdr pair-list)))))
      (is-in-list pair seen-pair-list))
    (define (mark-as-seen pair)
      (set! seen-pair-list (cons pair seen-pair-list)))
    (define (count-pairs-recur x)
      (cond ((not (pair? x)) 0)
            ((has-seen x) 0)
            (else
              (begin (mark-as-seen x)
                     (+ (count-pairs-recur (car x))
                        (count-pairs-recur (cdr x))
                        1)))))
    (count-pairs-recur x)))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define x1 '(() () ()))
(define x2
  (let ((common-pair (cons () ())))
   (list common-pair common-pair)))
(define x3
  (let ((inner-pair (cons () ())))
    (let ((middle-pair (cons inner-pair inner-pair)))
      (let ((outer-pair (cons middle-pair middle-pair)))
        outer-pair))))
(define x4
  (let ((l '(() () ())))
    (set-car! l l)
    l))

(count-pairs x1) ; 3 expected
(count-pairs x2) ; 3 expected
(count-pairs x3) ; 3 expected
(count-pairs x4) ; 3 expected
\end{lstlisting}

Result:

\begin{lstlisting}
3 ; pass
3 ; pass
3 ; pass
3 ; pass
\end{lstlisting}

\section{Exercise 3.18}

Code:

\begin{lstlisting}
(define (is-contain-cycle l)
  (let ((seen-pair-list '()))
    (define (has-seen pair)
      (define (is-in-list pair pair-list)
        (if (null? pair-list)
            #f
            (if (eq? pair (car pair-list))
                #t
                (is-in-list pair (cdr pair-list)))))
      (is-in-list pair seen-pair-list))
    (define (mark-as-seen pair)
      (set! seen-pair-list (cons pair seen-pair-list)))
    (define (is-contain-cycle-iter l)
      (cond ((not (pair? l)) #f)
            ((has-seen l) #t)
            (else
              (begin (mark-as-seen l)
                     (is-contain-cycle-iter (cdr l))))))
    (is-contain-cycle-iter l)))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define (make-cycle x)
  (define (last-pair x)
    (if (null? (cdr x))
        x
        (last-pair (cdr x))))
  (set-cdr! (last-pair x) x)
  x)
(define x (make-cycle '(1 2 3)))

(is-contain-cycle '(1 2 3)) ; #f expected
(is-contain-cycle '())      ; #f expected
(is-contain-cycle x)        ; #t expected
\end{lstlisting}

Result:

\begin{lstlisting}
#f ; pass
#f ; pass
#t ; pass
\end{lstlisting}

\section{Exercise 3.19}

Code:

\begin{lstlisting}
(define (is-contain-cycle l)
  (define (proceed l)
    (if (null? l)
        l
        (cdr l)))
  (define (tortoise-proceed tortoise)
    (proceed tortoise))
  (define (hare-proceed hare)
    (proceed (proceed hare)))
  (define (is-contain-cycle-iter tortoise hare)
    (cond ((or (null? tortoise)
               (null? hare))
           #f)
          ((eq? tortoise hare)
           #t)
          (else
           (is-contain-cycle-iter (tortoise-proceed tortoise)
                                  (hare-proceed hare)))))
  (is-contain-cycle-iter (tortoise-proceed l)
                         (hare-proceed l)))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define (make-cycle x)
  (define (last-pair x)
    (if (null? (cdr x))
        x
        (last-pair (cdr x))))
  (set-cdr! (last-pair x) x)
  x)

(is-contain-cycle '(1 2 3)) ; #f expected
(is-contain-cycle (make-cycle '(1 2 3))) ; #t expected
\end{lstlisting}

Result:

\begin{lstlisting}
#f ; pass
#t ; pass
\end{lstlisting}

\section{Exercise 3.20}

The process is as follows:

\begin{lstlisting}
(define x (cons 1 2))

global env
     |
     v
+---------+
| x -+    |    +------------+
+----+----+    |set-x!:...  |
     |         |set-y!:...  |
     v         |dispatch--+ |
     [+][+]--->|x:1       | |
     |    ^    |y:2       | |
     |    |    +----------+-+
     v    +---------------+
code of dispatch

(define z (cons x x))

global env
     |
     v
+---------+
| z ------+-------------------+
|         |<------------------+---+
| x -+    |    +------------+ |   |   +------------+
+----+----+<---|set-x!:...  | |   +---|set-x!:...  |
     |         |set-y!:...  | |       |set-y!:...  |
     v         |dispatch--+ | v       |dispatch--+ |
     [+][+]--->|x:1       | | [+][+]->|x--+      | |
     |    ^    |y:2       | | | ^     |y--+      | |
     |    |    +----------+-+ | |     +---+------+-+
     v    +---------------+---+-+-+       |      |
code of dispatch <------------+ | +-------+      |
                                +----------------+

(set-car! (cdr z) 17)

global env
     |
     v
+---------+
| z ------+-------------------+
|         |<------------------+---+
| x -+    |    +------------+ |   |   +------------+
+----+----+<---|set-x!:...  | |   +---|set-x!:...  |
     |         |set-y!:...  | |       |set-y!:...  |
     v         |dispatch--+ | v       |dispatch--+ |
     [+][+]--->|x:17      | | [+][+]->|x--+      | |
     |    ^    |y:2       | | | ^     |y--+      | |
     |    |    +----------+-+ | |     +---+------+-+
     v    +---------------+---+-+-+       |      |
code of dispatch <------------+ | +-------+      |
                                +----------------+
\end{lstlisting}

\section{Exercise 3.21}

The interpreter sees the queue as a 'list'
 with two elements (after at least one insertion
 has occured so that \lstinline{rear-ptr} do
 points at something). The first element is a
 list with its head indicated by
 \lstinline{front-ptr}. The second element
 is the element at the rear or the last element
 dequeued if the queue is empty.
 Note that the queue is regarded as the first element
 of the 'list' as a whole which contains the rear
 element already, and the rear element is again
 regarded as the second element of the 'list',
 making it appear twice when printed. And because
 we leave \lstinline{rear-ptr} still
 pointing at the former rear element after the
 last element in queue gets deleted, the former
 rear element would still be seen by the
 interpreter as the second element of the 'list'.

Code:

\begin{lstlisting}
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item)
  (set-car! queue item))
(define (set-rear-ptr! queue item)
  (set-cdr! queue item))
(define (empty-queue? queue)
  (null? (front-ptr queue)))
(define (make-queue) (cons '() '()))
(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue")
      (car (front-ptr queue))))
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (if (empty-queue? queue)
      (begin (set-front-ptr! queue new-pair)
             (set-rear-ptr! queue new-pair)
             queue)
      (begin (set-cdr! (rear-ptr queue) new-pair)
             (set-rear-ptr! queue new-pair)
             queue))))
(define (delete-queue! queue)
  (if (empty-queue? queue)
      (error "DELETE called with an empty queue")
      (begin (set-front-ptr! queue
                             (cdr (front-ptr queue)))
             queue)))

(define (print-queue q)
  (display (front-ptr q)))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define q (make-queue))
(print-queue q) ; () expected
(insert-queue! q -1)
(insert-queue! q 0)
(insert-queue! q 1)
(insert-queue! q 2)
(insert-queue! q 3)
(print-queue q) ; (-1 0 1 2 3) expected
(front-queue q) ; -1 expected
(delete-queue! q)
(print-queue q) ; (0 1 2 3) expected
\end{lstlisting}

Result:

\begin{lstlisting}
() ; pass
(-1 0 1 2 3) ; pass
-1 ; pass
(0 1 2 3)    ; pass
\end{lstlisting}

\section{Exercise 3.22}

Code:

\begin{lstlisting}
(define (make-queue)
  (let ((front-ptr '())
        (rear-ptr '())
        (queue '()))
    (define (empty?)
      (null? front-ptr))
    (define (front)
      (if (empty?)
          (error "FRONT called with an empty queue")
          (car front-ptr)))
    (define (insert! item)
      (let ((new-pair (cons item '())))
        (if (empty?)
            (begin (set! front-ptr new-pair)
                   (set! rear-ptr new-pair))
            (begin (set-cdr! rear-ptr new-pair)
                   (set! rear-ptr new-pair)))
        'ok))
    (define (delete!)
      (if (empty?)
          (error "DELETE called with an empty queue")
          (begin (set! front-ptr (cdr front-ptr))
                 'ok)))
    (define (print)
      (display front-ptr))
    (define (dispatch m)
      (cond ((eq? m 'empty?) empty?)
            ((eq? m 'front) front)
            ((eq? m 'insert!) insert!)
            ((eq? m 'delete!) delete!)
            ((eq? m 'print) print)
            (else (error "UNKNOWN METHOD" m))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define q (make-queue))
((q 'print)) ; () expected
((q 'insert!) -1)
((q 'insert!) 0)
((q 'insert!) 1)
((q 'insert!) 2)
((q 'insert!) 3)
((q 'print)) ; (-1 0 1 2 3) expected
((q 'front)) ; -1 expected
((q 'delete!))
((q 'print)) ; (0 1 2 3) expected
\end{lstlisting}

Result:

\begin{lstlisting}
() ; pass
(-1 0 1 2 3) ; pass
-1 ; pass
(0 1 2 3)    ; pass
\end{lstlisting}

\section{Exercise 3.23}

Code:

\begin{lstlisting}
;; doubly linked list node definition
(define (make-dlink-node prev item next)
  (cons prev (cons item next)))
(define (get-prev dlink-node)
  (car dlink-node))
(define (get-item dlink-node)
  (car (cdr dlink-node)))
(define (get-next dlink-node)
  (cdr (cdr dlink-node)))
(define (set-prev! dlink-node new-prev)
  (set-car! dlink-node new-prev))
(define (set-item! dlink-node new-item)
  (set-car! (cdr dlink-node) new-item))
(define (set-next! dlink-node new-next)
  (set-cdr! (cdr dlink-node) new-next))

;; deque definition
(define (make-deque)
  (cons '() '()))
(define (get-front-ptr deque)
  (car deque))
(define (get-rear-ptr deque)
  (cdr deque))
(define (set-front-ptr! deque new-front-ptr)
  (set-car! deque new-front-ptr))
(define (set-rear-ptr! deque new-rear-ptr)
  (set-cdr! deque new-rear-ptr))
(define (empty-deque? deque)
  (null? (get-front-ptr deque)))
(define (front-deque deque)
  (if (empty-deque? deque)
      (error "FRONT called with an empty deque")
      (get-item (get-front-ptr deque))))
(define (rear-deque deque)
  (if (empty-deque? deque)
      (error "REAR called with an empty deque")
      (get-item (get-rear-ptr deque))))
(define (insert-deque! deque item from-rear)
  (let ((new-node (make-dlink-node '() item '())))
    (if (empty-deque? deque)
        (begin (set-front-ptr! deque new-node)
               (set-rear-ptr! deque new-node))
        (if from-rear
            (begin (set-next! (get-rear-ptr deque)
                              new-node)
                   (set-prev! new-node
                              (get-rear-ptr deque))
                   (set-rear-ptr! deque new-node))
            (begin (set-prev! (get-front-ptr deque)
                              new-node)
                   (set-next! new-node
                              (get-front-ptr deque))
                   (set-front-ptr! deque new-node))))
    'ok))
(define (front-insert-deque! deque item)
  (insert-deque! deque item #f))
(define (rear-insert-deque! deque item)
  (insert-deque! deque item #t))
(define (delete-deque! deque from-rear)
  (if (empty-deque? deque)
      (error "DELETE called with an empty deque")
      (if from-rear
          (begin
            (set-rear-ptr! deque
                           (get-prev (get-rear-ptr deque)))
            (if (not (null? (get-rear-ptr deque)))
                (set-next! (get-rear-ptr deque)
                           '())
                (set-front-ptr! deque '()))
            'ok)
          (begin
            (set-front-ptr! deque
                            (get-next (get-front-ptr deque)))
            (if (not (null? (get-front-ptr deque)))
                (set-prev! (get-front-ptr deque)
                           '())
                '())
            'ok))))
(define (front-delete-deque! deque)
  (delete-deque! deque #f))
(define (rear-delete-deque! deque)
  (delete-deque! deque #t))
(define (print-deque deque)
  (define (print-dlist-iter dlist is-start)
    (cond ((null? dlist) '())
          (is-start
            (begin (display (get-item dlist))
                   (print-dlist-iter (get-next dlist)
                                     #f)))
          (else
            (begin (display " ")
                   (display (get-item dlist))
                   (print-dlist-iter (get-next dlist)
                                     #f)))))
  (display "(")
  (print-dlist-iter (get-front-ptr deque) #t)
  (display ")"))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define q (make-deque))
(print-deque q) ; () expected
(front-insert-deque! q 1)
(print-deque q) ; (1) expected
(rear-deque q)  ; 1 expected
(rear-delete-deque! q)
(print-deque q) ; () expected
(rear-insert-deque! q 1)
(rear-insert-deque! q 2)
(rear-insert-deque! q 3)
(print-deque q) ; (1 2 3) expected
(front-insert-deque! q 0)
(front-insert-deque! q -1)
(front-insert-deque! q -2)
(front-insert-deque! q -3)
(print-deque q) ; (-3 -2 -1 0 1 2 3) expected
(front-deque q) ; -3 expected
(rear-deque q)  ; 3 expected
\end{lstlisting}

Result:

\begin{lstlisting}
()      ; pass
(1)     ; pass
1       ; pass
()      ; pass
(1 2 3) ; pass
(-3 -2 -1 0 1 2 3) ; pass
-3      ; pass
3       ; pass
\end{lstlisting}

\section{Exercise 3.24}

In order to focus on the aspect of how
 \lstinline{same-key} operator can be adopted,
 here we simplify the problem by implementing
 a table with just one dimension. Implementation
 of table with arbitary dimension can be found
 later in solution to exercise 3.25.

Well basically it's just about using
 \lstinline{same-key?} instead of \lstinline{equal?}
 in \lstinline{assoc}.

Code:

\begin{lstlisting}
(define (make-table same-key?)
  (let ((local-table (list 'table)))
    (define (assoc key pairs)
      (cond ((null? pairs) '())
            ((same-key? key (car (car pairs)))
              (car pairs))
            (else (assoc key (cdr pairs)))))
    (define (lookup key)
      (let ((k-v (assoc key (cdr local-table))))
        (if (null? k-v)
            '()
            (cdr k-v))))
    (define (insert! key value)
      (let ((k-v (assoc key (cdr local-table))))
        (if (null? k-v)
            (set-cdr! local-table
                      (cons (cons key value)
                            (cdr local-table)))
            (set-cdr! k-v value))))
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert!) insert!)
            (else (error "UNKNOWN METHOD" m))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define t (make-table (lambda (k1 k2)
                        (< (abs (- k1 k2))
                           0.5))))
((t 'insert!) 1 'one)
((t 'insert!) 2 'two)
((t 'insert!) 3 'three)
((t 'insert!) 4 'four)
((t 'lookup) 4.6) ; () expected
((t 'lookup) 4.4) ; four expected
((t 'lookup) 4)   ; four expected
((t 'lookup) 3.6) ; four expected
((t 'lookup) 3.4) ; three expected
\end{lstlisting}

Result:

\begin{lstlisting}
()    ; pass
four  ; pass
four  ; pass
four  ; pass
three ; pass
\end{lstlisting}

\section{Exercise 3.25}

Basically it can be seen as an implementation
 of trie.

Code:

\begin{lstlisting}
(define (make-table)
  (let ((local-table (list 'table)))
    (define (assoc key pairs)
      (cond ((null? pairs) '())
            ((equal? key (car (car pairs)))
              (cdr (car pairs)))
              ;; here we return a pair
              ;; containing the value
              ;; and the table
              ;; associated with the key
              ;; they can be seen as
              ;; the content and the childs
              ;; of the tree node
            (else (assoc key (cdr pairs)))))
    (define (lookup keys)
      (define (lookup-iter table keys)
        ;; paramater table expects a pair
        ;; whose car contains value
        ;; and cdr contains subtable (pairs)
        (if (null? keys)
            (car table)
            (let ((v-t-pair (assoc (car keys)
                                   (cdr table))))
              (if (null? v-t-pair)
                  '()
                  (lookup-iter v-t-pair
                               (cdr keys))))))
      (lookup-iter local-table keys))
    (define (insert! keys value)
      (define (create-table keys value)
        (if (null? (cdr keys))
            (cons (car keys)
                  (cons value '()))
            (cons (car keys)
                  (cons '()
                        (list (create-table (cdr keys)
                                            value))))))
      (define (insert-iter! table keys value)
        ;; paramater table expects a pair
        ;; whose car contains value
        ;; and cdr contains subtable (pairs)
        (if (null? keys)
            (set-car! table value)
            (let ((v-t-pair (assoc (car keys)
                                   (cdr table))))
              (if (null? v-t-pair)
                  ;; entry not in table
                  ;; then create the entry
                  ;; and insert into table
                  (set-cdr! table
                            (cons (create-table keys
                                                value)
                                  (cdr table)))
                  (insert-iter! v-t-pair (cdr keys) value)))))
      (insert-iter! local-table keys value)
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert!) insert!)
            (else (error "UNKNOWN METHOD" m))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define t (make-table))
((t 'insert!) '(1) 1)
((t 'insert!) '(1 2) 12)
((t 'insert!) '(1 2 3) 123)
((t 'insert!) '(1 2 3 4) 1234)
((t 'lookup) '(1))       ; 1 expected
((t 'lookup) '(1 2))     ; 12 expected
((t 'lookup) '(1 2 3))   ; 123 expected
((t 'lookup) '(1 2 3 4)) ; 1234 expected
\end{lstlisting}

Result:

\begin{lstlisting}
1    ; pass
12   ; pass
123  ; pass
1234 ; pass
\end{lstlisting}

\end{document}









