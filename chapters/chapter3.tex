\documentclass[../main.tex]{subfiles}

\begin{document}

\section{Exercise 3.1}

Code:

\begin{lstlisting}
(define (make-accumulator sum)
  (lambda (x)
    (begin (set! sum (+ sum x))
           sum))))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define acc-5 (make-accumulator 5))
(acc-5 1) ; 6 expected
(acc-5 2) ; 8 expected
(acc-5 3) ; 11 expected
(acc-5 4) ; 15 expected
(acc-5 -15) ; 0 expected
(define acc-neg-1 (make-accumulator -1))
(acc-neg-1 11) ; 10 expected
\end{lstlisting}

Result:

\begin{lstlisting}
6  ; pass
8  ; pass
11 ; pass
15 ; pass
0  ; pass
10 ; pass
\end{lstlisting}

\section{Exercise 3.2}

Code:

\begin{lstlisting}
(define (make-monitored proc)
  (let ((count 0))
    (define (dispatch . args)
      (cond ((equal? args '(how-many-calls?)) count)
            ((equal? args '(reset-count))
             (begin (set! count 0)
                    'ok))
            (else (begin (set! count (+ 1 count))
                         (apply proc args)))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define s (make-monitored sqrt))
(s 'how-many-calls?) ; 0 expected
(s 100)              ; 10 expected
(s 49)               ; 7 expected
(s 1)                ; 1 expected
(s 0)                ; 0 expected
(s 'how-many-calls?) ; 4 expected
(s 'reset-count)     ; ok expected
(s 'how-many-calls?) ; 0 expected
(s 144)              ; 12 expected
(s 64)               ; 8 expected
(s 4)                ; 2 expected
(s 0)                ; 0 expected
(s 'how-many-calls?) ; 4 expected
\end{lstlisting}

Result:

\begin{lstlisting}
;; s defined
0  ; pass
10 ; pass
7  ; pass
1  ; pass
0  ; pass
4  ; pass
ok ; pass
0  ; pass
12 ; pass
8  ; pass
2  ; pass
0  ; pass
4  ; pass
\end{lstlisting}

\section{Exercise 3.3}

Code:

\begin{lstlisting}
(define (make-account balance password)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
               "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch pwd m)
    (cond ((not (eq? pwd password))
           (lambda args "Incorrect password"))
          ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (lambda args "Unknown method"))))
  dispatch)
\end{lstlisting}

Tests:

\begin{lstlisting}
(define my-account (make-account 100 'take-that))
((my-account 'take-that 'withdraw) 50) ; 50 expected
((my-account 'take-that 'deposit) 30)  ; 80 expected
((my-account 'take-this 'withdraw) 80) ; error expected
((my-account 'take-that 'withdraw) 80) ; 0 expected
\end{lstlisting}

Results:

\begin{lstlisting}
;; my-account defined
50                   ; pass
80                   ; pass
"Incorrect password" ; pass
0                    ; pass
\end{lstlisting}

\section{Exercise 3.4}

Code:

\begin{lstlisting}
(define (call-the-cops)
  "Hey you b**stard!")
(define (make-account balance password)
  (let ((error-count 0))
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (error . args)
      (if (< error-count 7)
          (begin (set! error-count (+ error-count 1))
                 "Incorrect password")
          (call-the-cops)))
    (define (dispatch pwd m)
      (if (not (eq? pwd password))
          error
          (begin (set! error-count 0)
                 (cond ((eq? m 'withdraw) withdraw)
                       ((eq? m 'deposit) deposit)
                       (else (lambda args "Unknown method"))))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define my-account (make-account 100 'take-that))
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; error expected
((my-account 'take-this 'withdraw) 50) ; cops expected
((my-account 'take-that 'withdraw) 50) ; 50 expected
\end{lstlisting}

Result:

\begin{lstlisting}
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Incorrect password" ; pass
"Hey you b**stard!"  ; pass
50                   ; pass
\end{lstlisting}

\section{Exercise 3.5}

Code:

\begin{lstlisting}
(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (/ (+ 0.0 trials-passed) trials))
          ((experiment)
           (iter (- trials-remaining 1) (+ trials-passed 1)))
          (else
           (iter (- trials-remaining 1) trials-passed))))
  (iter trials 0))
(define (estimate-integral P xl xu yl yu trials)
  (define (rand-range lower upper)
    (+ lower (random (- upper lower))))
  (define (experiment)
    (let ((x (rand-range xl xu))
          (y (rand-range yl yu)))
      (P x y)))
  (monte-carlo trials experiment))
\end{lstlisting}

Tests (same test for 5 times):

\begin{lstlisting}
(* 4
   (estimate-integral
     (lambda (x y)
       (< (+ (* x x) (* y y)) 1))
     -1.0 1.0 -1.0 1.0 100000)) ;; 3.14159 expected
\end{lstlisting}

Result:

\begin{lstlisting}
3.14116 ; pass
3.15324 ; pass
3.13736 ; pass
3.132   ; pass
3.14752 ; pass
\end{lstlisting}

\section{Exercise 3.6}

To test the code, a pseudo \lstinline{rand-update}
 procedure and a constant initial seed are used.

Code:

\begin{lstlisting}
(define rand
  (let ((x 2333))
    (define (rand-update x)
      (+ x 1))
    (define (generate)
      (set! x (rand-update x))
      x)
    (define (reset value)
      (set! x value)
      'ok)
    (define (dispatch method)
      (cond ((eq? method 'generate) (generate))
            ((eq? method 'reset) reset)
            (else (lambda args "Unknown method"))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
((rand 'reset) 0) ; ok expected
(rand 'generate)  ; 1 expected
(rand 'generate)  ; 2 expected
(rand 'generate)  ; 3 expected
((rand 'reset) 0) ; ok expected
(rand 'generate)  ; 1 expected
(rand 'generate)  ; 2 expected
(rand 'generate)  ; 3 expected
\end{lstlisting}

Result:

\begin{lstlisting}
ok ; pass
1  ; pass
2  ; pass
3  ; pass
ok ; pass
1  ; pass
2  ; pass
3  ; pass
\end{lstlisting}

\section{Exercise 3.7}

Code:

\begin{lstlisting}
;; original account definition
(define (make-account balance password)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch pwd m)
    (cond ((not (eq? pwd password))
           (lambda (amount) "Incorrect password"))
          ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (lambda args "Unknown method"))))
  dispatch)

;; joint account definition
(define (make-joint account password new-password)
  (define (withdraw amount)
    ((account password 'withdraw) amount))
  (define (deposit amount)
    ((account password 'deposit) amount))
  (define (dispatch pwd m)
    (cond ((not (eq? pwd new-password))
           (lambda (amount) "Incorrect password"))
          ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (lambda args "Unknown method"))))
  dispatch)
\end{lstlisting}

Tests:

\begin{lstlisting}
(define peter-acc (make-account 100 'peter))
(define paul-acc (make-joint peter-acc 'peter 'paul))
((paul-acc 'paul 'withdraw) 50) ; 50 expected
((peter-acc 'peter 'deposit) 100) ; 150 expected
((paul-acc 'paul 'withdraw) 0) ; 150 expected
((paul-acc 'peter 'withdraw) 0) ; error expected
\end{lstlisting}

Result:

\begin{lstlisting}
;; peter-acc defined
;; paul-acc defined
50  ; pass
150 ; pass
150 ; pass
"Incorrect password" ; pass
\end{lstlisting}

\section{Exercise 3.8}

Code:

\begin{lstlisting}
(define f
  (let ((multiplier 2))
    (lambda (x)
      (begin (set! multiplier (- multiplier 1))
             (* multiplier x)))))
\end{lstlisting}

\section{Exercise 3.9}

Recursive version:

\begin{lstlisting}
+-----------+
| factorial |<- global env
+-----------+
^    ^      ^
|    |      |
+---++---+  +---+
|n:6||n:5|..|n:1|
+---++---+  +---+
\end{lstlisting}

Iterative version:

\begin{lstlisting}
+-----------+
| factorial |<- global env
+-----------+
^    ^^^
|    |||..
+---++-----------+
|n:6||product:1  |
+---+|counter:1  |
     |max-count:6|
     +-----------+
      ||
     +-----------+
     |product:1  |
     |counter:2  |
     |max-count:6|
     +-----------+
       |
     +-----------+
     |product:2  |
     |counter:3  |
     |max-count:6|
     +-----------+
       ...
\end{lstlisting}

\section{Exercise 3.10}

Implicit local state version:

\begin{lstlisting}
(define W1 (make-withdraw 100))

+-----------------+
| make-withdraw:..|
| W1              |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |     +------------------+
  |     |initial-amount:100|
  |     +------------------+
  |              ^
  |              |
  v        +-----------+
  [+][+]-->|balance:100|
  |        +-----------+
  v
  code


(W1 50)

+----------------+
|make-withdraw:..|
|W1              |
| |              |
+-+--------------+
  |              ^
  |              |
  |     +------------------+
  |     |initial-amount:100|
  |     +------------------+
  |              ^
  |              |
  v        +----------+
  [+][+]-->|balance:50|
  |        +----------+
  v              ^
  code           |
           +-----------+
           | amount:50 |
           +-----------+


(define W2 (make-withdraw 100))

+---------------------------------------+
| make-withdraw:..                      |
| W2 ------------------------+          |<- global env
| W1                         |          |
| |                          |          |
+-+--------------------------+----------+
  |              ^           |          ^
  |              |           |          |
  |     +------------------+ | +------------------+
  |     |initial-amount:100| | |initial-amount:100|
  |     +------------------+ | +------------------+
  |              ^           v          ^
  |              |        [+][+]        |
  v        +----------+    |  |   +-----------+
  [+][+]-->|balance:50|    |  +-->|balance:100|
  |        +----------+    |      +-----------+
  v                        |
  code <-------------------+
\end{lstlisting}

Explicit local state version:

\begin{lstlisting}
(define W1 (make-withdraw 100))

+-----------------+
| make-withdraw:..|
| W1              |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |        +-----------+
  [+][+]-->|balance:100|
  |        +-----------+
  v
  code


(W1 50)

+----------------+
|make-withdraw:..|
|W1              |
| |              |
+-+--------------+
  |              ^
  |              |
  v        +----------+
  [+][+]-->|balance:50|
  |        +----------+
  v
  code


(define W2 (make-withdraw 100))
+---------------------------------------+
| make-withdraw:..                      |
| W2 ------------------------+          |<- global env
| W1                         |          |
| |                          |          |
+-+--------------------------+----------+
  |              ^           v          ^
  |              |        [+][+]        |
  v        +----------+    |  |   +-----------+
  [+][+]-->|balance:50|    |  +-->|balance:100|
  |        +----------+    |      +-----------+
  v                        |
  code <-------------------+
\end{lstlisting}

They act similarly except that in the former one
 redundant frame is created and never used
 by each account.
 
\section{Exercise 3.11}

The process is as follows:

\begin{lstlisting}
(define acc (make-account 50))

+-----------------+
| make-account:.. |
| acc             |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |     +--------------+
  |     | balance:50   |
  |     | withdraw:... |
  |     | deposit:...  |
  |  +--+ dispatch     |
  |  |  +--------------+
  |  |           ^
  v  v           |
  [+][+]---------+
  |
  v
  code of dispatch

((acc 'deposit) 40)

+-----------------+
| make-account:.. |
| acc             |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |     +--------------+. +----------+
  |     | balance:90   |<-|m:'deposit|
  |     | withdraw:... |  +----------+
  |     | deposit:...  |  +---------+
  |  +--+ dispatch     |<-|amount:40|
  |  |  +--------------+  +---------+
  |  |           ^
  v  v           |
  [+][+]---------+
  |
  v
  code of dispatch

((acc 'withdraw) 60)

+-----------------+
| make-account:.. |
| acc             |<- global env
| |               |
+-+---------------+
  |              ^
  |              |
  |     +--------------+. +-----------+
  |     | balance:30   |<-|m:'withdraw|
  |     | withdraw:... |  +-----------+
  |     | deposit:...  |  +---------+
  |  +--+ dispatch     |<-|amount:60|
  |  |  +--------------+  +---------+
  |  |           ^
  v  v           |
  [+][+]---------+
  |
  v
  code of dispatch

(define acc2 (make-account 100))

+-----------------+
| make-account:.. |<- global env
| acc2 -----------+------+
| acc             |      |
| |               |<-----+--+
+-+---------------+      |  |
  |              ^       |  |
  |              |       |  |
  |     +--------------+ | +--------------+
  |     | balance:30   | | | balance:100  |
  |     | withdraw:... | | | withdraw:... |
  |     | deposit:...  | | | deposit:...  |
  |  +--+ dispatch     | | | dispatch     |
  |  |  +--------------+ | +---+----------+
  |  |           ^       |     | ^
  v  v           |       v<----+ |
  [+][+]---------+  [+][+]-------+
  |                  |
  v                  |
  code of dispatch <-+
\end{lstlisting}

\lstinline{acc} and \lstinline{acc2} share code of
 procedure definitions (implementation dependent).
 
\section{Exercise 3.12}

The process is as follows:

\begin{lstlisting}
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))

x -> [+][+]->[+][x]
      |       |
      v       v
      a       b

y -> [+][+]->[+][x]
      |       |
      v       v
      c       d

z -> [+][+]->[+][+]->[+][+]->[+][x]
      |       |       |       |
      v       v       v       v
      a       b       c       d

(cdr x) ; returns (b)
(define w (append! x y))

      w
      |
      v
x -> [+][+]->[+][+]
      |       |  |
      v       v  |
      a       b  |
                 |
      +----------+
      |
      v
y -> [+][+]->[+][x]
      |       |
      v       v
      c       d

(cdr x) ; returns (b c d)
\end{lstlisting}

\section{Exercise 3.13}

The structure is as follows:

\begin{lstlisting}
      +------------------+
      |                  |
      v                  |
z -> [+][+]->[+][+]->[+][+]
      |       |       |
      v       v       v
      a       b       c
\end{lstlisting}

Evaluating \lstinline{(last-pair z)}
 creates an infinite loop.

\section{Exercise 3.14}

\lstinline{mystery} reverses the given list
 \lstinline{x} and returns the reversed list.

The structures of \lstinline{v} and \lstinline{w}
 are as follows:

\begin{lstlisting}
                              v
                              |
                              v
w -> [+][+]->[+][+]->[+][+]->[+][x]
      |       |       |       |
      v       v       v       v
      d       c       b       a
\end{lstlisting}

The value of \lstinline{w} is \lstinline{(d c b a)},
 and the value of \lstinline{v} is \lstinline{(a)}.

\section{Exercise 3.15}

The structures are as follows:

\begin{lstlisting}
z1 -> [+][+]
       |  |
       v  v
x  -> [+][+]->[+][x]
       |       |
       v       v
       wow     b

z2 -> [+][+]->[+][+]->[+][x]
       |       |       |
       |       v       v
       |       a       b
       |               ^
       |               |
       +------[+][+]->[+][x]
               |
               v
               wow
\end{lstlisting}

\section{Exercise 3.16}

The structures are as follows:

\begin{lstlisting}
x1 -> [x][+]->[x][+]->[+][x]

x2 -> [+][+]->[+][x]
       |       |
       +--+  +-+
          |  |
          v  v
         [x][x]

x3 -> [+][+]->[+][+]->[x][x]
       |     ^ |     ^
       |     | |     |
       +-----+ +-----+

x4 -> [+][+]->[x][+]->[+][x]
     ^ |
     | |
     +-+
\end{lstlisting}

Code:

\begin{lstlisting}
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define x1 '(() () ()))
(define x2
  (let ((common-pair (cons () ())))
   (list common-pair common-pair)))
(define x3
  (let ((inner-pair (cons () ())))
    (let ((middle-pair (cons inner-pair inner-pair)))
      (let ((outer-pair (cons middle-pair middle-pair)))
        outer-pair))))
(define x4
  (let ((l '(() () ())))
    (set-car! l l)
    l))

(count-pairs x1) ; 3 expected
(count-pairs x2) ; 4 expected
(count-pairs x3) ; 7 expected
(count-pairs x4) ; infinite recursive calls expected
\end{lstlisting}

Result:

\begin{lstlisting}
3 ; pass
4 ; pass
7 ; pass
;; maximum recursion depth exceeded, pass
\end{lstlisting}

\section{Exercise 3.17}

Code:

\begin{lstlisting}
(define (count-pairs x)
  (let ((seen-pair-list '()))
    (define (has-seen pair)
      (define (is-in-list pair pair-list)
        (if (null? pair-list)
            #f
            (if (eq? pair (car pair-list))
                #t
                (is-in-list pair (cdr pair-list)))))
      (is-in-list pair seen-pair-list))
    (define (mark-as-seen pair)
      (set! seen-pair-list (cons pair seen-pair-list)))
    (define (count-pairs-recur x)
      (cond ((not (pair? x)) 0)
            ((has-seen x) 0)
            (else
              (begin (mark-as-seen x)
                     (+ (count-pairs-recur (car x))
                        (count-pairs-recur (cdr x))
                        1)))))
    (count-pairs-recur x)))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define x1 '(() () ()))
(define x2
  (let ((common-pair (cons () ())))
   (list common-pair common-pair)))
(define x3
  (let ((inner-pair (cons () ())))
    (let ((middle-pair (cons inner-pair inner-pair)))
      (let ((outer-pair (cons middle-pair middle-pair)))
        outer-pair))))
(define x4
  (let ((l '(() () ())))
    (set-car! l l)
    l))

(count-pairs x1) ; 3 expected
(count-pairs x2) ; 3 expected
(count-pairs x3) ; 3 expected
(count-pairs x4) ; 3 expected
\end{lstlisting}

Result:

\begin{lstlisting}
3 ; pass
3 ; pass
3 ; pass
3 ; pass
\end{lstlisting}

\section{Exercise 3.18}

Code:

\begin{lstlisting}
(define (is-contain-cycle l)
  (let ((seen-pair-list '()))
    (define (has-seen pair)
      (define (is-in-list pair pair-list)
        (if (null? pair-list)
            #f
            (if (eq? pair (car pair-list))
                #t
                (is-in-list pair (cdr pair-list)))))
      (is-in-list pair seen-pair-list))
    (define (mark-as-seen pair)
      (set! seen-pair-list (cons pair seen-pair-list)))
    (define (is-contain-cycle-iter l)
      (cond ((not (pair? l)) #f)
            ((has-seen l) #t)
            (else
              (begin (mark-as-seen l)
                     (is-contain-cycle-iter (cdr l))))))
    (is-contain-cycle-iter l)))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define (make-cycle x)
  (define (last-pair x)
    (if (null? (cdr x))
        x
        (last-pair (cdr x))))
  (set-cdr! (last-pair x) x)
  x)
(define x (make-cycle '(1 2 3)))

(is-contain-cycle '(1 2 3)) ; #f expected
(is-contain-cycle '())      ; #f expected
(is-contain-cycle x)        ; #t expected
\end{lstlisting}

Result:

\begin{lstlisting}
#f ; pass
#f ; pass
#t ; pass
\end{lstlisting}

\section{Exercise 3.19}

Code:

\begin{lstlisting}
(define (is-contain-cycle l)
  (define (proceed l)
    (if (null? l)
        l
        (cdr l)))
  (define (tortoise-proceed tortoise)
    (proceed tortoise))
  (define (hare-proceed hare)
    (proceed (proceed hare)))
  (define (is-contain-cycle-iter tortoise hare)
    (cond ((or (null? tortoise)
               (null? hare))
           #f)
          ((eq? tortoise hare)
           #t)
          (else
           (is-contain-cycle-iter (tortoise-proceed tortoise)
                                  (hare-proceed hare)))))
  (is-contain-cycle-iter (tortoise-proceed l)
                         (hare-proceed l)))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define (make-cycle x)
  (define (last-pair x)
    (if (null? (cdr x))
        x
        (last-pair (cdr x))))
  (set-cdr! (last-pair x) x)
  x)

(is-contain-cycle '(1 2 3)) ; #f expected
(is-contain-cycle (make-cycle '(1 2 3))) ; #t expected
\end{lstlisting}

Result:

\begin{lstlisting}
#f ; pass
#t ; pass
\end{lstlisting}

\section{Exercise 3.20}

The process is as follows:

\begin{lstlisting}
(define x (cons 1 2))

global env
     |
     v
+---------+
| x -+    |    +------------+
+----+----+    |set-x!:...  |
     |         |set-y!:...  |
     v         |dispatch--+ |
     [+][+]--->|x:1       | |
     |    ^    |y:2       | |
     |    |    +----------+-+
     v    +---------------+
code of dispatch

(define z (cons x x))

global env
     |
     v
+---------+
| z ------+-------------------+
|         |<------------------+---+
| x -+    |    +------------+ |   |   +------------+
+----+----+<---|set-x!:...  | |   +---|set-x!:...  |
     |         |set-y!:...  | |       |set-y!:...  |
     v         |dispatch--+ | v       |dispatch--+ |
     [+][+]--->|x:1       | | [+][+]->|x--+      | |
     |    ^    |y:2       | | | ^     |y--+      | |
     |    |    +----------+-+ | |     +---+------+-+
     v    +---------------+---+-+-+       |      |
code of dispatch <------------+ | +-------+      |
                                +----------------+

(set-car! (cdr z) 17)

global env
     |
     v
+---------+
| z ------+-------------------+
|         |<------------------+---+
| x -+    |    +------------+ |   |   +------------+
+----+----+<---|set-x!:...  | |   +---|set-x!:...  |
     |         |set-y!:...  | |       |set-y!:...  |
     v         |dispatch--+ | v       |dispatch--+ |
     [+][+]--->|x:17      | | [+][+]->|x--+      | |
     |    ^    |y:2       | | | ^     |y--+      | |
     |    |    +----------+-+ | |     +---+------+-+
     v    +---------------+---+-+-+       |      |
code of dispatch <------------+ | +-------+      |
                                +----------------+
\end{lstlisting}

\section{Exercise 3.21}

The interpreter sees the queue as a 'list'
 with two elements (after at least one insertion
 has occured so that \lstinline{rear-ptr} do
 points at something). The first element is a
 list with its head indicated by
 \lstinline{front-ptr}. The second element
 is the element at the rear or the last element
 dequeued if the queue is empty.
 Note that the queue is regarded as the first element
 of the 'list' as a whole which contains the rear
 element already, and the rear element is again
 regarded as the second element of the 'list',
 making it appear twice when printed. And because
 we leave \lstinline{rear-ptr} still
 pointing at the former rear element after the
 last element in queue gets deleted, the former
 rear element would still be seen by the
 interpreter as the second element of the 'list'.

Code:

\begin{lstlisting}
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item)
  (set-car! queue item))
(define (set-rear-ptr! queue item)
  (set-cdr! queue item))
(define (empty-queue? queue)
  (null? (front-ptr queue)))
(define (make-queue) (cons '() '()))
(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue")
      (car (front-ptr queue))))
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (if (empty-queue? queue)
      (begin (set-front-ptr! queue new-pair)
             (set-rear-ptr! queue new-pair)
             queue)
      (begin (set-cdr! (rear-ptr queue) new-pair)
             (set-rear-ptr! queue new-pair)
             queue))))
(define (delete-queue! queue)
  (if (empty-queue? queue)
      (error "DELETE called with an empty queue")
      (begin (set-front-ptr! queue
                             (cdr (front-ptr queue)))
             queue)))

(define (print-queue q)
  (display (front-ptr q)))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define q (make-queue))
(print-queue q) ; () expected
(insert-queue! q -1)
(insert-queue! q 0)
(insert-queue! q 1)
(insert-queue! q 2)
(insert-queue! q 3)
(print-queue q) ; (-1 0 1 2 3) expected
(front-queue q) ; -1 expected
(delete-queue! q)
(print-queue q) ; (0 1 2 3) expected
\end{lstlisting}

Result:

\begin{lstlisting}
() ; pass
(-1 0 1 2 3) ; pass
-1 ; pass
(0 1 2 3)    ; pass
\end{lstlisting}

\section{Exercise 3.22}

Code:

\begin{lstlisting}
(define (make-queue)
  (let ((front-ptr '())
        (rear-ptr '())
        (queue '()))
    (define (empty?)
      (null? front-ptr))
    (define (front)
      (if (empty?)
          (error "FRONT called with an empty queue")
          (car front-ptr)))
    (define (insert! item)
      (let ((new-pair (cons item '())))
        (if (empty?)
            (begin (set! front-ptr new-pair)
                   (set! rear-ptr new-pair))
            (begin (set-cdr! rear-ptr new-pair)
                   (set! rear-ptr new-pair)))
        'ok))
    (define (delete!)
      (if (empty?)
          (error "DELETE called with an empty queue")
          (begin (set! front-ptr (cdr front-ptr))
                 'ok)))
    (define (print)
      (display front-ptr))
    (define (dispatch m)
      (cond ((eq? m 'empty?) empty?)
            ((eq? m 'front) front)
            ((eq? m 'insert!) insert!)
            ((eq? m 'delete!) delete!)
            ((eq? m 'print) print)
            (else (error "UNKNOWN METHOD" m))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define q (make-queue))
((q 'print)) ; () expected
((q 'insert!) -1)
((q 'insert!) 0)
((q 'insert!) 1)
((q 'insert!) 2)
((q 'insert!) 3)
((q 'print)) ; (-1 0 1 2 3) expected
((q 'front)) ; -1 expected
((q 'delete!))
((q 'print)) ; (0 1 2 3) expected
\end{lstlisting}

Result:

\begin{lstlisting}
() ; pass
(-1 0 1 2 3) ; pass
-1 ; pass
(0 1 2 3)    ; pass
\end{lstlisting}

\section{Exercise 3.23}

Code:

\begin{lstlisting}
;; doubly linked list node definition
(define (make-dlink-node prev item next)
  (cons prev (cons item next)))
(define (get-prev dlink-node)
  (car dlink-node))
(define (get-item dlink-node)
  (car (cdr dlink-node)))
(define (get-next dlink-node)
  (cdr (cdr dlink-node)))
(define (set-prev! dlink-node new-prev)
  (set-car! dlink-node new-prev))
(define (set-item! dlink-node new-item)
  (set-car! (cdr dlink-node) new-item))
(define (set-next! dlink-node new-next)
  (set-cdr! (cdr dlink-node) new-next))

;; deque definition
(define (make-deque)
  (cons '() '()))
(define (get-front-ptr deque)
  (car deque))
(define (get-rear-ptr deque)
  (cdr deque))
(define (set-front-ptr! deque new-front-ptr)
  (set-car! deque new-front-ptr))
(define (set-rear-ptr! deque new-rear-ptr)
  (set-cdr! deque new-rear-ptr))
(define (empty-deque? deque)
  (null? (get-front-ptr deque)))
(define (front-deque deque)
  (if (empty-deque? deque)
      (error "FRONT called with an empty deque")
      (get-item (get-front-ptr deque))))
(define (rear-deque deque)
  (if (empty-deque? deque)
      (error "REAR called with an empty deque")
      (get-item (get-rear-ptr deque))))
(define (insert-deque! deque item from-rear)
  (let ((new-node (make-dlink-node '() item '())))
    (if (empty-deque? deque)
        (begin (set-front-ptr! deque new-node)
               (set-rear-ptr! deque new-node))
        (if from-rear
            (begin (set-next! (get-rear-ptr deque)
                              new-node)
                   (set-prev! new-node
                              (get-rear-ptr deque))
                   (set-rear-ptr! deque new-node))
            (begin (set-prev! (get-front-ptr deque)
                              new-node)
                   (set-next! new-node
                              (get-front-ptr deque))
                   (set-front-ptr! deque new-node))))
    'ok))
(define (front-insert-deque! deque item)
  (insert-deque! deque item #f))
(define (rear-insert-deque! deque item)
  (insert-deque! deque item #t))
(define (delete-deque! deque from-rear)
  (if (empty-deque? deque)
      (error "DELETE called with an empty deque")
      (if from-rear
          (begin
            (set-rear-ptr! deque
                           (get-prev (get-rear-ptr deque)))
            (if (not (null? (get-rear-ptr deque)))
                (set-next! (get-rear-ptr deque)
                           '())
                (set-front-ptr! deque '()))
            'ok)
          (begin
            (set-front-ptr! deque
                            (get-next (get-front-ptr deque)))
            (if (not (null? (get-front-ptr deque)))
                (set-prev! (get-front-ptr deque)
                           '())
                '())
            'ok))))
(define (front-delete-deque! deque)
  (delete-deque! deque #f))
(define (rear-delete-deque! deque)
  (delete-deque! deque #t))
(define (print-deque deque)
  (define (print-dlist-iter dlist is-start)
    (cond ((null? dlist) '())
          (is-start
            (begin (display (get-item dlist))
                   (print-dlist-iter (get-next dlist)
                                     #f)))
          (else
            (begin (display " ")
                   (display (get-item dlist))
                   (print-dlist-iter (get-next dlist)
                                     #f)))))
  (display "(")
  (print-dlist-iter (get-front-ptr deque) #t)
  (display ")"))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define q (make-deque))
(print-deque q) ; () expected
(front-insert-deque! q 1)
(print-deque q) ; (1) expected
(rear-deque q)  ; 1 expected
(rear-delete-deque! q)
(print-deque q) ; () expected
(rear-insert-deque! q 1)
(rear-insert-deque! q 2)
(rear-insert-deque! q 3)
(print-deque q) ; (1 2 3) expected
(front-insert-deque! q 0)
(front-insert-deque! q -1)
(front-insert-deque! q -2)
(front-insert-deque! q -3)
(print-deque q) ; (-3 -2 -1 0 1 2 3) expected
(front-deque q) ; -3 expected
(rear-deque q)  ; 3 expected
\end{lstlisting}

Result:

\begin{lstlisting}
()      ; pass
(1)     ; pass
1       ; pass
()      ; pass
(1 2 3) ; pass
(-3 -2 -1 0 1 2 3) ; pass
-3      ; pass
3       ; pass
\end{lstlisting}

\section{Exercise 3.24}

In order to focus on the aspect of how
 \lstinline{same-key} operator can be adopted,
 here we simplify the problem by implementing
 a table with just one dimension. Implementation
 of table with arbitary dimension can be found
 later in solution to exercise 3.25.

Well basically it's just about using
 \lstinline{same-key?} instead of \lstinline{equal?}
 in \lstinline{assoc}.

Code:

\begin{lstlisting}
(define (make-table same-key?)
  (let ((local-table (list 'table)))
    (define (assoc key pairs)
      (cond ((null? pairs) '())
            ((same-key? key (car (car pairs)))
              (car pairs))
            (else (assoc key (cdr pairs)))))
    (define (lookup key)
      (let ((k-v (assoc key (cdr local-table))))
        (if (null? k-v)
            '()
            (cdr k-v))))
    (define (insert! key value)
      (let ((k-v (assoc key (cdr local-table))))
        (if (null? k-v)
            (set-cdr! local-table
                      (cons (cons key value)
                            (cdr local-table)))
            (set-cdr! k-v value))))
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert!) insert!)
            (else (error "UNKNOWN METHOD" m))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define t (make-table (lambda (k1 k2)
                        (< (abs (- k1 k2))
                           0.5))))
((t 'insert!) 1 'one)
((t 'insert!) 2 'two)
((t 'insert!) 3 'three)
((t 'insert!) 4 'four)
((t 'lookup) 4.6) ; () expected
((t 'lookup) 4.4) ; four expected
((t 'lookup) 4)   ; four expected
((t 'lookup) 3.6) ; four expected
((t 'lookup) 3.4) ; three expected
\end{lstlisting}

Result:

\begin{lstlisting}
()    ; pass
four  ; pass
four  ; pass
four  ; pass
three ; pass
\end{lstlisting}

\section{Exercise 3.25}

Basically it can be seen as an implementation
 of trie.

Code:

\begin{lstlisting}
(define (make-table)
  (let ((local-table (list 'table)))
    (define (assoc key pairs)
      (cond ((null? pairs) '())
            ((equal? key (car (car pairs)))
              (cdr (car pairs)))
              ;; here we return a pair
              ;; containing the value
              ;; and the table
              ;; associated with the key
              ;; they can be seen as
              ;; the content and the childs
              ;; of the tree node
            (else (assoc key (cdr pairs)))))
    (define (lookup keys)
      (define (lookup-iter table keys)
        ;; paramater table expects a pair
        ;; whose car contains value
        ;; and cdr contains subtable (pairs)
        (if (null? keys)
            (car table)
            (let ((v-t-pair (assoc (car keys)
                                   (cdr table))))
              (if (null? v-t-pair)
                  '()
                  (lookup-iter v-t-pair
                               (cdr keys))))))
      (lookup-iter local-table keys))
    (define (insert! keys value)
      (define (create-table keys value)
        (if (null? (cdr keys))
            (cons (car keys)
                  (cons value '()))
            (cons (car keys)
                  (cons '()
                        (list (create-table (cdr keys)
                                            value))))))
      (define (insert-iter! table keys value)
        ;; paramater table expects a pair
        ;; whose car contains value
        ;; and cdr contains subtable (pairs)
        (if (null? keys)
            (set-car! table value)
            (let ((v-t-pair (assoc (car keys)
                                   (cdr table))))
              (if (null? v-t-pair)
                  ;; entry not in table
                  ;; then create the entry
                  ;; and insert into table
                  (set-cdr! table
                            (cons (create-table keys
                                                value)
                                  (cdr table)))
                  (insert-iter! v-t-pair (cdr keys) value)))))
      (insert-iter! local-table keys value)
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert!) insert!)
            (else (error "UNKNOWN METHOD" m))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define t (make-table))
((t 'insert!) '(1) 1)
((t 'insert!) '(1 2) 12)
((t 'insert!) '(1 2 3) 123)
((t 'insert!) '(1 2 3 4) 1234)
((t 'lookup) '(1))       ; 1 expected
((t 'lookup) '(1 2))     ; 12 expected
((t 'lookup) '(1 2 3))   ; 123 expected
((t 'lookup) '(1 2 3 4)) ; 1234 expected
\end{lstlisting}

Result:

\begin{lstlisting}
1    ; pass
12   ; pass
123  ; pass
1234 ; pass
\end{lstlisting}

\section{Exercise 3.26}

Just like exercise 3.24, we implement a simple table
 with just one dimension to focus on how binary
 search tree is implemented.

Code:

\begin{lstlisting}
(define (make-bst-table)
  (define (make-bst-node item)
    (cons '() (cons item '())))
  (define (get-left bst-node)
    (car bst-node))
  (define (get-right bst-node)
    (cdr (cdr bst-node)))
  (define (get-item bst-node)
    (car (cdr bst-node)))
  (define (set-left! bst-node left-node)
    (set-car! bst-node left-node))
  (define (set-right! bst-node right-node)
    (set-cdr! (cdr bst-node) right-node))
  (define (set-item! bst-node new-item)
    (set-car! (cdr bst-node) new-item))
  (let ((bst-root '()))
    (define (lookup key)
      (define (lookup-iter curr-node)
        (if (null? curr-node)
            '()
            (let ((k-v (get-item curr-node)))
              (cond ((= key
                        (car k-v))
                      (cdr k-v))
                    ((< key
                        (car k-v))
                      (lookup-iter (get-left curr-node)))
                    (else
                      (lookup-iter (get-right curr-node)))))))
      (lookup-iter bst-root))
    (define (insert! key value)
      (define (insert-iter! curr-node)
        (let ((k-v (get-item curr-node)))
          (cond ((= key (car k-v))
                  (set-cdr! k-v value))
                ((< key (car k-v))
                  (try-insert-left! curr-node))
                (else
                  (try-insert-right! curr-node)))))
      (define (try-insert-next! curr-node
                                next-getter
                                next-setter)
        (if (null? (next-getter curr-node))
            (next-setter curr-node
                         (make-bst-node (cons key 
                                              value)))
            (insert-iter! (next-getter curr-node))))
      (define (try-insert-left! curr-node)
        (try-insert-next! curr-node
                          get-left
                          set-left!))
      (define (try-insert-right! curr-node)
        (try-insert-next! curr-node
                          get-right
                          set-right!))
      (if (null? bst-root)
          (set! bst-root (make-bst-node (cons key
                                              value)))
          (insert-iter! bst-root))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert!) insert!)
            (else (error "UNKNOWN METHOD" m))))
    dispatch))
\end{lstlisting}

Tests:

\begin{lstlisting}
(define t (make-bst-table))
((t 'insert!) 3 'three)
((t 'insert!) 1 'one)
((t 'insert!) 4 'four)
((t 'insert!) 5 'five)
((t 'insert!) 9 'nine)
((t 'lookup) 1) ; one expected
((t 'lookup) 3) ; three expected
((t 'lookup) 4) ; four expected
((t 'lookup) 5) ; five expected
((t 'lookup) 9) ; nine expected
\end{lstlisting}

Result:

\begin{lstlisting}
one   ; pass
three ; pass
four  ; pass
five  ; pass
nine  ; pass
\end{lstlisting}

\section{Exercise 3.27}

The environment is as follows:

\begin{lstlisting}
global env
     |
     v
+----------+
| memo-fib |<-----------+
|    |     |<-+         |
+----+-----+  |         |
     |     +-----+      |
     |     |f----+---+  |
     |     +-----+   |  |
     |        ^      v  |
     |        |      [+][+]
     |   +---------+ |
     |   |table:...| v
     |   +---------+ code (compute fib)
     |        ^
     v        |
     [+][+]---+
     |
     v
     code (table lookup)
\end{lstlisting}

From the fact that computing the $k$th
 Fibonacci number requires only the $(k-1)$th and the
 $(k-2)$th Fibonacci number, we know that computing
 the $n$th Fibonacci number requires nothing more
 than the $n$ numbers from the $0$th Fibonacci
 number to the $(n-1)$th Fibonacci number.

From the fact that the $k$th Fibonacci number
 can be found in the table after it's been computed
 for the first time, we know that each of the $n$
 Fibonacci numbers mentioned above only gets
 computed once at most when computing the $n$th
 Fibonacci number.

Therefore, computing the $n$th Fibonacci number
 takes $\Theta(n)$ steps (provided that the table
 is implemented as hash table and each insertion
 and lookup takes $O(1)$ steps).

The scheme won't work if we simply define
 \lstinline{memo-fib} to be
 \lstinline{(memoize fib)}, since invocation
 of \lstinline{fib} inside the body won't
 look up in the table.

In addition, I saw an interesting solution on
 the Internet, saying that

\begin{lstlisting}
(set! fib (memoize fib))
\end{lstlisting}

will do the trick. Let's find out whether it's
 true.

When we first define \lstinline{fib}, the
 environment is as follows:
 
\begin{lstlisting}
global env
   |
   v
+-----+
| fib |
|  |  |<--+
+--+--+   |
   |      |
   v      |
   [+][+]-+
   |
   v
   code (compute fib)
\end{lstlisting}

After doing the magic, the environment becomes
 as follows:
 
\begin{lstlisting}
global env
    |
    v
+---------+
| fib     |<-----------+
|   |     |<-+         |
+---+-----+  |         |
    |     +-----+      |
    |     |f----+---+  |
    |     +-----+   |  |
    |        ^      v  |
    |        |      [+][+]
    |   +---------+ |
    |   |table:...| v
    |   +---------+ code (compute fib)
    |        ^
    v        |
    [+][+]---+
    |
    v
    code (table lookup)
\end{lstlisting}

Looks like everything's fine! How about some tests?

Basically we want to ensure that every invocation
 of \lstinline{fib} is decorated by
 \lstinline{memoize}, so we can just display
 a message when \lstinline{memoize} is invoked.
 To make the code executable and also to avoid
 introducing a great bunch of code implementing
 table, here we just use a pseudo
 \lstinline{memoize} instead of a real one.

Code:

\begin{lstlisting}
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
(define (memoize f)
  (let ((count 0))
    (lambda (x)
      (set! count (+ count 1))
      (display "I've been invoked for ")
      (display count)
      (display " times!\n")
      (f x))))
(set! fib (memoize fib))
\end{lstlisting}

Tests:

\begin{lstlisting}
(fib 3) ;; 5 memoize invocations expected
\end{lstlisting}

Result:

\begin{lstlisting}
I've been invoked for 1 times!
I've been invoked for 2 times!
I've been invoked for 3 times!
I've been invoked for 4 times!
I've been invoked for 5 times!
2 ; pass
\end{lstlisting}

\section{Exercise 3.28}

Code:

\begin{lstlisting}
(define (or-gate a1 a2 output)
  (define (or-action-procedure)
    (let ((new-value
           (logical-or (get-signal a1)
                       (get-signal a2))))
      (after-delay or-gate-delay
                   (lambda ()
                     (set-signal! output
                                  new-value)))))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure)
  'ok)

(define (logical-or signal1 signal2)
  (if (or (= signal1 1)
          (= signal2 1))
      1
      0))
\end{lstlisting}

\section{Exercise 3.29}

Code:

\begin{lstlisting}
(define (or-gate a1 a2 output)
  (let ((c (make-wire))
        (d (make-wire))
        (e (make-wire)))
    (inverter a1 c)
    (inverter a2 d)
    (and-gate c d e)
    (inverter e output)
    'ok))
\end{lstlisting}

The delay time is

$$
\text{inverter-delay} * 2 + \text{and-gate-delay}
$$

\section{Exercise 3.30}

Code:

\begin{lstlisting}
(define (ripple-carry-adder a-lst b-lst s-lst c)
  (if (null? a-lst)
      'ok
      (let ((cout (make-wire)))
        (begin (full-adder (car a-lst)
                           (car b-lst)
                           c
                           (car s-lst)
                           cout)
               (ripple-carry-adder (cdr a-lst)
                                   (cdr b-lst)
                                   (cdr s-lst)
                                   cout)))))
\end{lstlisting}

The delay times of a half adder are

\begin{align*}
\text{delay}_{S} &= \max \{ \text{and-gate-delay} + \text{inverter-delay}, \text{or-gate-delay} \} + \text{and-gate-delay} \\
\text{delay}_{C} &= \text{and-gate-delay}
\end{align*}

Thus the delay times of a full adder are

\begin{align*}
\text{delay}_{SUM} &= \text{delay}_{S} * 2 \\
\text{delay}_{COUT} &= \text{delay}_{S} + \text{delay}_{C} + \text{or-gate-delay}
\end{align*}

Thus the delay times of a full ripple-carry adder are

\begin{align*}
\text{delay}_{S1} &= \text{delay}_{S} \\
\text{delay}_{S2} &= \text{delay}_{COUT} + \text{delay}_{S} \\
&\vdots \\
\text{delay}_{SN} &= \text{delay}_{COUT} * (n - 1) + \text{delay}_{S}
\end{align*}

\section{Exercise 3.31}

Calling \lstinline{propagate} may not trigger the probe if we
had defined \lstinline{accept-action-procedure!} the other way.
The initialization guarantees the consistency of the whole
digital circuit (as long as the actions of one wire don't conflict
with each other).

\section{Exercise 3.32}

This order must be used to ensure the final state of digital
circuits is determined by the last change (which is quite natural).

Suppose the procedures are stored in a LIFO queue (i.e. a stack).
And suppose we first change one of the input signals from 1 to 0, and then
the other from 0 to 1. After changing the first signal from 1 to 0,
current signals of two inputs are both 0, thus the procedure setting
output to 0 is put onto stack. Then after changing the second signal
from 0 to 1, the procedure setting output to 1 is put onto stack.
After some delay when these two procedures are invoked, the output
signal first get set to 1 then get set to 0, which produces the wrong result.

\section{Exercise 3.33}

Code:

\begin{lstlisting}
(define (averager a b c)
  (let ((p (make-connector))
        (q (make-connector)))
    (adder a b p)
    (multiplier c q p)
    (constant 2 q)
    'ok))
\end{lstlisting}

\section{Exercise 3.34}

Setting the value of \lstinline{b} won't
produce value for \lstinline{a} since the multiplier
is still expecting another value from connector.

\section{Exercise 3.35}

Code:

\begin{lstlisting}
(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (< (get-value b) 0)
            (error "square less than 0 -- SQUARER" (get-value b))
            (set-value! a (sqrt (get-value b)) me))
        (set-value! b (square (get-value a)) me)))
  (define (process-forget-value)
    (forget-value! a me)
    (forget-value! b me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value) (process-new-value))
          ((eq? request 'I-lost-my-value) (process-forget-value))
          (else (error "Unknown request -- SQUARER" request))))
  (connect a me)
  (connect b me)
  me)
\end{lstlisting}

\section{Exercise 3.36}

Environment (it's just so painful to draw such gragh in \LaTeX):

\begin{lstlisting}
  +---------------------+
  | global env          |
  |                     |
  | make-connector: ... |
+-+-a                   |
| + b: ...              |
| +---------------------+<+
|                         |
| +---------------------+-+
| | (empty environment) |
| +---------------------+<-+
|                          |
| +----------------------+-+
| | value: 10            |
| | informant: 'user     |
| | constraints: '()     |
| +----------------------+
| | set-my-value: ...    |
| | forget-my-value: ... |
| | connect: ...         |
| | me--+                |
| +-----+----------------+
|       | ^
|       v |
+------>#.#
        |
        v
   (code of me)
\end{lstlisting}

\section{Exercise 3.37}

Code:

\begin{lstlisting}
(define (c- x y)
  (let ((z (make-connector)))
    (adder y z x)
    z))
(define (c* x y)
  (let ((z (make-connector)))
    (multiplier x y z)
    z))
(define (c/ x y)
  (let ((z (make-connector)))
    (multiplier y z x)
    z))
(define (cv v)
  (let ((z (make-connector)))
    (constant v z)
    z))
\end{lstlisting}

\section{Exercise 3.38}

\subsection{a.}

\begin{itemize}
\item peter-paul-mary: 45
\item peter-mary-paul: 35
\item paul-peter-mary: 45
\item paul-mary-peter: 50
\item mary-peter-paul: 40
\item mary-paul-peter: 40
\end{itemize}

\subsection{b.}

Omitted. The total number of orderings is

$$
\frac{11!}{3!\,3!\,5!} = 9240
$$

\section{Exercise 3.39}

The first thunk contains the following "atomic" operations:

\begin{itemize}
\item[a)] get x, compute x * x and let t1 be the result
\item[b)] set x with t1
\end{itemize}

The second thunk contains the following "atomic"
operation:

\begin{itemize}
\item[c)] get x, compute x + 1 and set x with the result
\end{itemize}

Each of the following sequences of execution gives corresponding result:

\begin{itemize}
\item a-b-c: 101
\item a-c-b: 100
\item c-a-b: 121
\end{itemize}

\section{Exercise 3.40}

The first thunk contains the following "atomic" operations:

\begin{itemize}
\item[a)] get x and let t1 be the result
\item[b)] get x and let t2 be the result
\item[c)] compute t1 * t2 and let t3 be the result
\item[d)] set x with t3
\end{itemize}

The second thunk contains the following "atomic"
operation:

\begin{itemize}
\item[e)] get x and let t4 be the result
\item[f)] get x and let t5 be the result
\item[g)] get x and let t6 be the result
\item[h)] compute t4 * t5 * t6 and let t7 be the result
\item[i)] set x with t7
\end{itemize}

Each of the following sequences of execution gives corresponding result. Note that not every permutation is listed since what actually matters is when the variable is set with new value.

(i is invoked before d)

\begin{itemize}
\item e-f-g-h-i-a-b-c-d: 1000000
\item e-f-g-h-a-i-b-c-d: 10000
\item e-f-g-h-a-b-c-i-d: 100
\end{itemize}

(i is invoked after d)

\begin{itemize}
\item a-b-c-d-e-f-g-h-i: 1000000
\item a-b-c-e-d-f-g-h-i: 100000
\item a-b-c-e-f-d-g-h-i: 10000
\item a-b-c-e-f-g-h-d-i: 1000
\end{itemize}

If serialized procedures are used, then there're only one possibility left, which is 1000000.

\section{Exercise 3.41}

That really depends on implementation. If accessing variable and setting variable are not interleavable, indicating that one cannot access a variable and get a partially set value, then the protection is not necessary.

\section{Exercise 3.42}

Depends on the implementation of serialization. If serialization doesn't allow one serialized method to interleave with itself (the exact same object), then there's no difference between these two different versions.

\section{Exercise 3.43}

\subsection{a.}

To prove that after any number of sequential exchanges the account balances should be \$10, \$20 and \$30 in some order, we use induction as follows:

\begin{itemize}
\item \textbf{Base case}: Before any exchange get made, the account balances are \$10, \$20 and \$30.
\item \textbf{Induction step}: If the account balances are \$10, \$20 and \$30 in some order before one exchange, they are still \$10, \$20 and \$30 in some other order after the exchange.
\end{itemize}

The proof is valid thanks to the fact that no exchange can be interleaved with another.

\subsection{b.}

Suppose account A, B and C have \$10, \$20 and \$30 respectively. Suppose Peter is trying to exchange account A with account B, while Paul is trying to exchange account A with account C.

The execution order could be as follows:

\begin{enumerate}
\item Peter finishes computing the difference between account A and account B, and is ready to deposit \$10 to account A and withdraw from account B.
\item Paul suddenly comes in and finishes exchanging account A and account C, leaving \$30 in account A and \$10 in account C.
\item Peter continues his exchange, leaving \$40 in account A and \$10 in account B.
\end{enumerate}

\subsection{c.}

The sum will be perserved ONLY IF none of the operations fail, while in the actual case, they might.

Consider the case we discussed in the last question. After all exchanges we have \$40 in account A, \$10 in account B and \$10 in account C. If we do it again---exchange between account A and account C right away after Peter computes the difference between account A and account B, then Peter would try to withdraw \$30 from account A. This would cause a failure but in a such a silent way that Peter would still deposit \$30 into account C. In the end there're \$10, \$40 and \$40 in three accounts respectively.

\subsection{d.}

It's obvious and has been discussed in previous segments.

\section{Exercise 3.44}

Louis is not right.

In the exchange procedure, the amount transferred DEPENDS on the balance of each account. Therefore any change to any of the account during that transfer makes the amount of transfer invalid.

In the transfer procedure, the amount transferred is INDEPENDENT of the balance of each account. Besides, given the balance is always adequate for withdraw, serialized operations on one account can be performed in arbitary order, and the result is unique.

\section{Exercise 3.45}

Serialized exchange can't either withdraw or deposit since the three of them are serialized by the same serializer.

\section{Exercise 3.46}

Timing diagram showing how both processes can aquire one mutex at the same time:

\begin{lstlisting}
 Process A     Process B
     |             .
     v             .
 (car cell)        .
 returns false     .
     |             .
     +-(interrupt)-+
     .             |
     .             v
     .         (car cell)
     .         returns false
     .             |
     .             v
     .      set cell content
     .  to true and return false
     .             |
     +-(interrupt)-+
     |
     v
set cell content
to true and return false
\end{lstlisting}

\section{Exercise 3.47}

\subsection{a.}

Code:

\begin{lstlisting}
(define (make-semaphore n)
  (let ((value n)
        (mutex (make-mutex)))
    (define (p)
      (mutex 'acquire)
      (if (> value 0)
          (begin (set! value (- value 1))
                 (mutex 'release))
          (begin (mutex 'release)
                 (p))))
    (define (v)
      (mutex 'acquire)
      (if (>= value n)
          (mutex 'release)
          (begin (set! value (+ value 1))
                 (mutex 'release))))
    (define (dispatch m)
      (cond ((eq? m 'P) (p))
            ((eq? m 'V) (v))))
    dispatch))
\end{lstlisting}

\subsection{b.}

Isn't that just expanding the code of mutex?

\section{Exercise 3.48}

Deadlock happens when there are $n$ processes ($n \ge 2$), in which process $p_i (i < n)$ holds lock $l_i$ and asks for lock $l_{i+1}$, and process $p_n$ holds lock $l_n$ and asks for lock $l_1$.

After giving an order to accounts (i.e. locks) and specify the order of locking in exchange procedure, assume that deadlock still happens, then we have $l_i < l_{i+1} (i < n)$, from which we have $l_1 < l_n$. However, we also have $l_n < l_1$, which produces a contradiction. Using proof of contradiction, we know that such deadlock won't happen.

Code is ommited.

\section{Exercise 3.49}

Cancel latest transaction from one account. One need to lock this account, query whom the last transaction was to and then lock that account.

\section{Exercise 3.50}

Code:

\begin{lstlisting}
(define (stream-map proc . argstreams)
  (if (stream-null? (car argstreams))
      the-empty-stream
      (cons-stream
       (apply proc (map stream-car argstreams))
       (apply stream-map
              (cons proc (map stream-cdr argstreams))))))
\end{lstlisting}

\section{Exercise 3.51}

\begin{itemize}
\item 0
\item 1 2 3 4 5
\item 6 7
\end{itemize}

When evaluating \lstinline{(stream-ref x 7)}, numbers from 1 to 5 are not printed due to memoization.

\section{Exercise 3.52}

Value of \lstinline{sum} after evaluating each expression:

\begin{lstlisting}
(define sum 0) ; sum : 0
(define (accum x)
  (set! sum (+ x sum))
  sum) ; sum : 0
(define seq (stream-map accum (stream-enumerate-interval 1 20))) ; sum : 1
(define y (stream-filter even? seq)) ; sum : 6
(define z
        (stream-filter (lambda (x)
                               (= (remainder x 5)
                                  0))
                       seq)) ; sum : 10
(stream-ref y 7) ; sum : 136
(display-stream z) ; sum : 210
\end{lstlisting}

Evaluating \lstinline{(stream-ref y 7)} returns 136. Evaluating \lstinline{(display-stream z)} prints 10, 15, 45, 55, 105, 120, 190, 210.

The responses would differ. With memoization, after each element in \lstinline{seq} is computed (i.e. added to \lstinline{sum}), the element is stored and is never computed again, which ensures that every number between 1 and 20 is added to \lstinline{sum} only once. Without memoization, a number is added to \lstinline{sum} every time one element in \lstinline{seq} is visited.

\section*{Supporting code for following exercises}

Code:

\begin{lstlisting}
(define (stream-to-list n stream)
  (if (> n 0)
      (cons (stream-car stream)
            (stream-to-list (- n 1)
                            (stream-cdr stream)))
      '()))
(define (make-stream start next transform)
  (define (helper curr)
    (cons-stream (transform curr)
                 (helper (next curr))))
  (helper start))
(define (make-ns n)
  (make-stream n
               (lambda (x) x)
               (lambda (x) x)))
(define (stream-add . argstreams)
  (apply stream-map (cons + argstreams)))
(define (stream-sub s1 s2)
  (stream-map - s1 s2))
(define (stream-mul . argstreams)
  (apply stream-map (cons * argstreams)))
(define (stream-scale s k)
  (stream-map (lambda (x) (* k x))
              s))

(define ones
        (cons-stream 1 ones))
\end{lstlisting}

Solutions involving streams uses definitions above, among which some may be differently named with those on book.

\section{Exercise 3.53}

Power of two (1, 2, 4, 8, ...).

\section{Exercise 3.54}

Code:

\begin{lstlisting}
(define factorials
        (cons-stream 1
                     (stream-mul integers
                                 factorials)))
\end{lstlisting}

\section{Exercise 3.55}

Code:

\begin{lstlisting}
;; version 1
(define (partial-sums s)
  (cons-stream (stream-car s)
               (stream-add (make-ns (stream-car s))
                           (partial-sums (stream-cdr s)))))

;; version 2
(define (partial-sums s)
  (make-stream (cons (stream-car s)
                     (stream-cdr s))
               (lambda (p)
                       (cons (+ (car p)
                                (stream-car (cdr p)))
                             (stream-cdr (cdr p))))
               car))
\end{lstlisting}

\section{Exercise 3.56}

Code:

\begin{lstlisting}
(define (stream-merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((< s1car s2car)
                  (cons-stream s1car
                               (stream-merge (stream-cdr s1) s2)))
                 ((> s1car s2car)
                  (cons-stream s2car
                               (stream-merge s1 (stream-cdr s2))))
                 (else
                  (cons-stream s1car
                               (stream-merge (stream-cdr s1)
                                             (stream-cdr s2)))))))))

(define s
        (cons-stream 1
                     (stream-merge (stream-merge (stream-scale s 2)
                                                 (stream-scale s 3))
                                   (stream-scale s 5))))
\end{lstlisting}

\section{Exercise 3.57}

\subsection{With memoization}

Computing the first two Fibonacci numbers requires no addition. Computing every next Fibonacci number requires two preceding ones, which are already computed and memorized, and one addition. Thus the number of additions performed computing the $n$th Fibonacci number is

$$
cost(n) =
\begin{cases}
0 & n \le 2\\
n - 2 & n > 2
\end{cases}
$$

which is $\Theta(n)$.

Intuitively the computation process is quite like three pointers moving down a linked list, where when two of the pointers move down, they can reuse the elements generated by the first pointer ahead.

\subsection{Without memoization}

Computing the first two Fibonacci numbers requires no addition. Computing every next Fibonacci number requires two preceding ones, which are very much likely to not have been computed (except the first and second), and one addition. Thus the number of additions performed computing the $n$th Fibonacci number is

$$
cost(n) =
\begin{cases}
0 & n \le 2\\
cost(n-1) + cost(n-2) + 1 & n > 2
\end{cases}
$$

Denote $cost(n)$ as $a_n$, we have

\begin{align*}
a_n &= a_{n-1} + a{n-2} + 1 & (n \ge 3)\\
a_n + ka_{n-1} &= (k+1)a_{n-1} + a_{n-2} + 1 & (n \ge 3)
\end{align*}

Let $\frac{1}{k+1}=k$, we have

\begin{align*}
& \frac{1}{1+k} = k\\
\implies & k^2 + k - 1 = 0\\
\implies & k = -\frac{1 \pm \sqrt{5}}{2}
\end{align*}

Here we let $k$ be the negative root so that $a_n$ can be expressed in the form

$$
a_n = -ka_{n-1} + \alpha(n)
$$

where $-k$ is positive, making calcuation easier.

Denote $a_n + (-\frac{1+\sqrt{5}}{2})a_{n-1}$ as $b_n (n \ge 2)$, we have

\begin{align*}
b_n &= \frac{1-\sqrt{5}}{2} b_{n-1} + 1 & (n \ge 3)\\
b_n + m &= \frac{1-\sqrt{5}}{2} b_{n-1} + m + 1 & (n \ge 3)
\end{align*}

Let $\frac{1-\sqrt{5}}{2} = \frac{m+1}{m}$, we have

\begin{align*}
& \frac{1-\sqrt{5}}{2} = \frac{m+1}{m}\\
\implies & m = \frac{1-\sqrt{5}}{2}
\end{align*}

Denote $b_n + \frac{1-\sqrt{5}}{2}$ as $c_n (n \ge 2)$, we have

\begin{align*}
c_n &= \frac{1-\sqrt{5}}{2}c_{n-1} & (n \ge 2)
\end{align*}

Note that we have $c_2 = \frac{1-\sqrt{5}}{2}$, therefore we have

\begin{align*}
 c_n &= \left (\frac{1-\sqrt{5}}{2}\right )^{n-1} & (n \ge 2)\\
\implies b_n &= \left (\frac{1-\sqrt{5}}{2}\right )^{n-1} - \frac{1-\sqrt{5}}{2} & (n \ge 2)\\
\implies a_n &= \frac{1+\sqrt{5}}{2}a_{n-1} + \left (\frac{1-\sqrt{5}}{2}\right )^{n-1} - \frac{1-\sqrt{5}}{2} & (n \ge 2)
\end{align*}

Some verifications:

\begin{align*}
a_2 &= \frac{1-\sqrt{5}}{2} - \frac{1-\sqrt{5}}{2} = 0\\
a_3 &= \left (\frac{1-\sqrt{5}}{2}\right )^2 - \frac{1-\sqrt{5}}{2} = 1\\
a_4 &= \frac{1+\sqrt{5}}{2} + \left (\frac{1-\sqrt{5}}{2}\right )^{3} - \frac{1-\sqrt{5}}{2} = 2
\end{align*}it

Looks great!

Denote $\frac{1+\sqrt{5}}{2}$ as $p$ and $\frac{1-\sqrt{5}}{2}$ as $q$, we have

\begin{align*}
a_n &= pa_{n-1} + q^{n-1} - q\\
&= p(pa_{n-2} + q^{n-2} - q) + q^{n-1} - q\\
&= p^2a_{n-2} + (q^{n-1} + pq^{n-2}) - q(1 + p)\\
&= p^3a_{n-3} + (q^{n-1} + pq^{n-2} + p^2q^{n-3}) - q(1 + p + p^2)\\
&\vdots\\
&= p^{n-1}a_1 + \sum_{i=1}^{n-1}p^{n-1-i}q^i - q\frac{1-p^{n-1}}{1-p}\\
&= \sum_{i=1}^{n-1}p^{n-1-i}q^i + p^{n-1} - 1 (n \ge 1)
\end{align*}

It's really hard to tell the complexity, but by plotting we can actually tell that $a_n$ grows exponetially. To really prove the complexity, we need cleverer methods.

\section{Exercise 3.58}

\lstinline{Expand} generates decimal part of $\frac{num}{den}$ with $radix$ as base, given that $num \neq 0 \mod den$ and $radix > 1$.

Evaluating \lstinline{(expand 1 7 10)} produces the stream of $1, 4, 2, 8, 5, 7, 1, 4, 2, 8 \dots$

Evaluating \lstinline{(expand 3 8 10)} produces the stream of $3, 7, 5, 0, 0, 0, 0 \dots$

\section{Exercise 3.59}

\subsection{a.}

Code:

\begin{lstlisting}
(define (integrate-series coefstream)
  (define (integrate-helper coefs power)
    (if (stream-null? coefs)
        '()
        (cons-stream (/ (stream-car coefs)
                        power)
                     (integrate-helper (stream-cdr coefs)
                                       (+ power 1)))))
  (integrate-helper coefstream 1))
\end{lstlisting}

\subsection{b.}

Code:

\begin{lstlisting}
(define cosine-series
  (cons-stream 1
               (stream-scale
                (integrate-series sine-series)
                -1)))

(define sine-series
  (cons-stream 0 (integrate-series cosine-series)))
\end{lstlisting}

\section{Exercise 3.60}

Let $a$ be $\sum_{i=0}a_ix^i$ and $b$ be $\sum_{j=0}b_jx^j$, then $ab$ is

\begin{align*}
& (a_0b_0)x^0\\
+& (a_0b_1 + a_1b_0)x^1\\
+& (a_0b_2 + a_1b_1 + a_2b_0)x^2\\
+& (a_0b_3 + a_1b_2 + a_2b_1 + a_2b_0)x^3\\
\vdots
\end{align*}

Thus the code is as follows:

\begin{lstlisting}
(define (mul-series a b)
  (cons-stream
   (* (stream-car a)
      (stream-car b))
   (stream-add (stream-scale (stream-cdr b)
                             (stream-car a))
               (mul-series (stream-cdr a) b))))
\end{lstlisting}

\section{Exercise 3.61}

Code:

\begin{lstlisting}
(define (invert-unit-series s)
  (define x
    (cons-stream 1
                 (stream-scale
                  (mul-series (stream-cdr s)
                              x)
                  -1)))
  x)
\end{lstlisting}

\section{Exercise 3.62}

Code:

\begin{lstlisting}
(define (div-series a b)
  (let ((head (/ (stream-car a)
                 (stream-car b))))
    (cons-stream head
                 (div-series
                  (stream-sub (stream-cdr a)
                              (stream-scale
                               (stream-cdr b)
                               head))
                  b))))

(define tangent-series
        (div-series sine-series
                    cosine-series))
\end{lstlisting}

\section*{Some more analysis}

Here are one of the crazy streams \lstinline{integers} mentioned in previous section:

\begin{lstlisting}
(define ones (cons-stream 1 ones))
(define integers
  (cons-stream 1
               (stream-add ones
                           integers)
\end{lstlisting}

Analyzing the time and space complexity becomes not so trivial. Specifically, after some careful thought we can see that \lstinline{integer} is corrent, but its efficiency remains quite mysterious. Does it keep track of lots of streams? How much computation does it need to compute the next term? The following section will be discussing the above two matters using the environment model mentioned earlier in the book.

Here's the environment with \lstinline{ones} and \lstinline{integers} defined:

\begin{lstlisting}
+--------------+
| global env   |
| ------------ |
| ones: #0     |
| integers: #1 |
+--------------+

objects:
#0: [1 | ones @ global env]
#1: [1 | (stream-add ones integers) @ global env]
\end{lstlisting}

After we define \lstinline{integers1} as \lstinline{(stream-cdr integers)}, the environment is as follows:

\begin{lstlisting}
+---------------+
| global env    |
| ------------- |
| ones: #0      |
| integers: #1  |
| integers1: #2 |
+---------------+
       ^
       |
+--------------+
| stream-add#0 |
| ------------ |
| s1: #0       |
| s2: #1       |
+--------------+

objects:
#0: [1 | ones @ global env]
#1: [1 | #2]
#2: [2 | (stream-add (stream-cdr s1)
                     (stream-cdr s2)) @ stream-add#0]
\end{lstlisting}

After we define \lstinline{integers2} as \lstinline{(stream-cdr integers1)}, the environment is as follows:

\begin{lstlisting}
+---------------+
| global env    |
| ------------- |
| ones: #0      |
| integers: #1  |
| integers1: #2 |
| integers2: #3 |
+---------------+
       ^
       +---------+
       |         |
+--------------+ +--------------+
| stream-add#0 | | stream-add#1 |
| ------------ | | ------------ |
| s1: #0       | | s1: #0       |
| s2: #1       | | s2: #2       |
+--------------+ +--------------+

objects:
#0: [1 | #0]
#1: [1 | #2]
#2: [2 | #3]
#3: [3 | (stream-add (stream-cdr s1)
                     (stream-cdr s2)) @ stream-add#1]
\end{lstlisting}

Similarly, after we define \lstinline{integers3} as \lstinline{(stream-cdr integers2)}, the environment is as follows:

\begin{lstlisting}
+---------------+
| global env    |
| ------------- |
| ones: #0      |
| integers: #1  |
| integers1: #2 |
| integers2: #3 |
| integers3: #4 |
+---------------+
       ^
       +---------+----------------+
       |         |                |
+--------------+ +--------------+ +--------------+
| stream-add#0 | | stream-add#1 | | stream-add#2 |
| ------------ | | ------------ | | ------------ |
| s1: #0       | | s1: #0       | | s1: #0       |
| s2: #1       | | s2: #2       | | s2: #3       |
+--------------+ +--------------+ +--------------+

objects:
#0: [1 | #0]
#1: [1 | #2]
#2: [2 | #3]
#3: [3 | #4]
#4: [4 | (stream-add (stream-cdr s1)
                     (stream-cdr s2)) @ stream-add#2]
\end{lstlisting}

Things worthy to notice:

\begin{itemize}
\item There's only a single instance of \lstinline{one} stream through out the process.
\item Only one addition is needed each time \lstinline{stream-cdr} is invoked, thanks to the fact that previous results of \lstinline{stream-cdr} are memorized.
\item Another benefit of memoization is that old frames \lstinline{stream-add#0} and \lstinline{stream-add#1} are no longer needed. Frame \lstinline{stream-add#2} is still needed because the promise of object \lstinline{#4} has yet to be forced.
\end{itemize}

If we only include \lstinline{integers3} (not \lstinline{integers1} and \lstinline{integers2}) in the global environment, then the environment would be like (after garbage collection):

\begin{lstlisting}
+---------------+
| global env    |
| ------------- |
| ones: #0      |
| integers: #1  |
| integers3: #4 |
+---------------+
       ^
       |
+--------------+
| stream-add#2 |
| ------------ |
| s1: #0       |
| s2: #3       |
+--------------+

objects:
#0: [1 | #0]
#1: [1 | #2]
#2: [2 | #3]
#3: [3 | #4]
#4: [4 | (stream-add (stream-cdr s1)
                     (stream-cdr s2)) @ stream-add#2]
\end{lstlisting}

The environment is all nice and clean, but the entire "chain" is preserved due to memoization. This may not be the preferred behaviour in particular cases, where every element is only used once. What if memoization is removed?

Here's the environment with \lstinline{ones} and \lstinline{integers} defined:

\begin{lstlisting}
+--------------+
| global env   |
| ------------ |
| ones: #0     |
| integers: #1 |
+--------------+

objects:
#0: [1 | ones @ global env]
#1: [1 | (stream-add ones integers) @ global env]
\end{lstlisting}

After we define \lstinline{integers3} to be \lstinline{(stream-cdr (stream-cdr (stream-cdr integers)))}, the environment is as follows:

\begin{lstlisting}
+--------------+
| global env   |
| ------------ |
| ones: #0     |
| integers: #1 |
+--------------+
       ^
       +---------+----------------+
       |         |                |
+--------------+ +--------------+ +--------------+ 
| stream-add#0 | | stream-add#1 | | stream-add#2 |
| ------------ | | ------------ | | ------------ |
| s1: #0       | | s1: #0       | | s1: #0       |
| s2: #1       | | s2: #1       | | s2: #3       |
+--------------+ +--------------+ +--------------+

objects:
#0: [1 | ones @ global env]
#1: [1 | (stream-add ones integers) @ global env]
#2: [2 | (stream-add (stream-cdr s1)
                     (stream-cdr s2)) @ stream-add#0]
#3: [2 | (stream-add (stream-cdr s1)
                     (stream-cdr s2)) @ stream-add#1]
#4: [3 | (stream-add (stream-cdr s1)
                     (stream-cdr s2)) @ stream-add#2]
\end{lstlisting}

The environment is not complete (actually we've just computed \lstinline{(stream-cdr (stream-cdr integers))}), but it's obvious that the process is growing exponentially. If we continue to perform \lstinline{stream-cdr} on object \lstinline{#4}, we'll need to compute:

\begin{lstlisting}
- (stream-cdr #4) as #7
  - (stream-cdr #0) returns #0
  - (stream-cdr #3) as #6
    - (stream-cdr #0) returns #0
    - (stream-cdr #1) as #5
\end{lstlisting}

How can we exploit streams as if there's a local state? That seems to remain unsolved for now...

\end{document}









