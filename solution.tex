\documentclass[a4paper]{report}

\usepackage{listings}
\usepackage{courier}
\usepackage{titlesec}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{tikz}

\titlespacing{\section}{0pt}{32pt}{16pt}
\titlelabel{Exercise \thesection}

\lstset{basicstyle=\footnotesize\ttfamily, breaklines=true, frame=single, language=Lisp}

\begin{document}

\title{Solutions \\
\large Structure and Interpretation of Computer Programs}
\author{Eric Wen}
\date{Last Modified: April 2017}
\maketitle

\begin{multicols}{2}
	\tableofcontents
\end{multicols}

%
% chapter 1
%

\chapter{Building Abstractions with Procedures}

% exercise 1.1

\section{}

\begin{multicols}{2}
	\begin{itemize}
		\item 10
		\item 12
		\item 8
		\item 3
		\item 6
		\item a (with value 3)
		\item b (with value 4)
		\item 19
		\item \#f (true)
		\item 4
		\item 16
		\item 6
		\item 16
	\end{itemize}
\end{multicols}

% exercise 1.2

\section{}

\begin{lstlisting}
(/ (+ 5
      4
      (- 2
         (- 3
            (+ 6
               (/ 4 3)))))
   (* 3
      (- 6 2)
      (- 2 7)))
\end{lstlisting}

% exercise 1.3

\section{}

\begin{lstlisting}
(define (min2 a b)
        (if (< a b)
            a
            b))
(define (min3 a b c)
        (min2 a
              (min2 b c)))
(define (square x)
        (* x x))
(define (f a b c)
        (- (+ (square a)
              (square b)
              (square c))
           (square (min3 a b c))))
\end{lstlisting}

% exercise 1.4

\section{}

If b is positive, evaluate \lstinline{(- a b)} (i.e. a - b), otherwise evaluate \lstinline{(+ a b)} (i.e. a + b).

% exercise 1.5

\section{}

\subsection*{Applicative-order Evaluation}

\begin{lstlisting}
(test 0 (p)) ->
(test 0 (p)) ->
(test 0 (p)) ->
(test 0 (p)) ->
......
\end{lstlisting}

In applicative-order evaluation, a procedure is not reduced until all its arguments are evaluated. Thus the expression \lstinline{(p)} is constantly being expanded into itself over and over again while the procedure \lstinline{test} can never get the chance to be reduced.

\subsection*{Normal-order Evaluation}

\begin{lstlisting}
(test 0 (p)) ->
(if (= 0 0) 0 (p)) ->
0
\end{lstlisting}

In normal-order evaluation, a procedure's arguments are not evaluated until they're needed, which means the procedure is always reduced until it only involves primitive operators before its arguments are evaluated. Due to the special evaluation rule of \lstinline{if} where the alternative expression is not evaluated if the predicate expression is evaluated to be true, the function \lstinline{test} returns 0 before \lstinline{(p)} gets the chance to be evaluated.

% exercise 1.6

\section{}

The program will run infinitely until it runs out of memory.

\lstinline{if} has a special evaluation rule where either the consequent or the alternative expression is evaluated depending on the value of the predicate expression. In the implementation of Newton's Method, the procedure should immediately return current value when the value is good enough, and here's where \lstinline{if} comes in: if the requirement is met, the recursive call is not made.
 
But the program using \lstinline{new-if} always evaluates both the consequent and the alternative expression, causing the procedure to recursively call itself infinitely.

% exercise 1.7

\section{}

For very small numbers, the threshold value 0.001 is too large to tell if current estimation is close enough to real value.

\lstinline{(sqrt 0.00000001)} returns 0.03125, while 0.0001 is the real value.

For very large numbers, the precision is lost during calculation, hence the estimation can never get close enough ('close' defined by the threshold value 0.001) to real value.

\lstinline{(sqrt (expt 10 150))} fails to return within a reasonable time.

Code after improvement:

\begin{lstlisting}
(define (sqrtIter guess lastGuess x)
        (if (goodEnough guess lastGuess)
            guess
            (sqrtIter (improve guess x)
                      guess
                      x)))
(define (improve guess x)
        (average guess
                 (/ x guess)))
(define (average x y)
        (/ (+ x y)
           2))
(define (goodEnough guess lastGuess)
        (< (/ (abs (- guess lastGuess))
              lastGuess)
           0.001))
(define (sqrt x)
        (sqrtIter 1.0 x x))
\end{lstlisting}

After improvement, function calls mentioned above return 1e-4 and 1e75 respectively.

% exercise 1.8

\section{}

\begin{lstlisting}
(define (cbrtIter guess lastGuess x)
        (if (goodEnough guess lastGuess)
            guess
            (cbrtIter (improve guess x)
                      guess
                      x)))
(define (improve guess x)
        (/ (+ (/ x
                 (* guess guess))
              (* guess 2))
           3))
(define (goodEnough guess lastGuess)
        (< (/ (abs (- guess lastGuess))
              lastGuess)
           0.001))
(define (cbrt x)
        (cbrtIter 1.0 x x))
\end{lstlisting}

% exercise 1.9

\section{}

\begin{lstlisting}
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
\end{lstlisting}

The process is recursive.

\begin{lstlisting}
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
\end{lstlisting}

The process is iterative.

% exercise 1.10

\section{}

\begin{lstlisting}
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
...
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
...
(A 0 512)
(* 2 512)
(1024
\end{lstlisting}

\begin{lstlisting}
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 (* 2 2)))
(A 1 (A 1 4))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
(A 1 (A 0 (A 0 (A 0 2))))
(A 1 (A 0 (A 0 (* 2 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 (* 2 4)))
(A 1 (A 0 8))
(A 1 (* 2 8))
(A 1 16)
...
65536
\end{lstlisting}

\begin{lstlisting}
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1)))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1)))
(A 2 (A 0 2))
(A 2 (* 2 2))
(A 2 4)
...
65536
\end{lstlisting}

\begin{itemize}
\item \lstinline{(f n)} equals \lstinline{(A 0 n)} equals \lstinline{(* 2 n)} which computes 2n for positive n.
\item \lstinline{(g n)} equals \lstinline{(A 1 n)} equals \lstinline{(A 0 (A 1 (- n 1)))} equals \lstinline{(* 2 (A 1 (- n 1)))} (which, though, is not the way it's evaluated). In the basic case \lstinline{(A 1 1)} returns 2, thus \lstinline{(g n)} computes $2^n$ for positive n.
\item \lstinline{(h n)} equals \lstinline{(A 2 n)} equals \lstinline{(A 1 (A 2 (- n 1)))} equals \lstinline{(expt 2 (A 2 (- n 1)))} (which, though, is not the way it's evaluated). In the basic case \lstinline{(A 2 1)} returns 2. Informally, \lstinline{(h n)} computes $2^{2^{2^{...}}}$ where the number of 2 is n. The concise definition can be given recursively as follows: \lstinline{(h 1)} returns 2 for 1, and returns \lstinline{(expt 2 (h (- n 1)))} for n larger than 1.
\end{itemize}

% exercise 1.11

\section{}

Recursive version:

\begin{lstlisting}
(define (f n)
        (if (< n 3)
            n
            (+ (f (- n 1))
               (* 2 (f (- n 2)))
               (* 3 (f (- n 3))))))
\end{lstlisting}

Iterative version:

\begin{lstlisting}
(define (f n)
        (define (fIter n curr a b c)
                (if (= curr n)
                    a
                    (fIter n (+ 1 curr) (+ a (* 2 b) (* 3 c)) a b)))
        (if (< n 3)
            n
            (fIter n 2 2 1 0)))
\end{lstlisting}

% exercise 1.12

\section{}

\begin{lstlisting}
(define (pascal line row)
        (if (or (= row 1)
                (= row line))
            1
            (+ (pascal (- line 1) (- row 1))
               (pascal (- line 1) row))))
\end{lstlisting}

% exercise 1.13

\section{}

Let $\phi = \frac{1 + \sqrt{5}}{2}$, $\psi = \frac{1 - \sqrt{5}}{2}$.

Let $f(n) = \frac{\phi ^ n - \psi ^ n}{\sqrt{5}}$. Then there are $f(0) = 0$, $f(1) = 1$.

For any n larger than 1, consider $f(n - 1)$ and $f(n - 2)$:

\begin{align*}
f(n-1) + f(n-2) &= \frac{\phi^{n-1} + \phi^{n-2}-(\psi^{n-1}+\psi^{n-2})}{\sqrt{5}} \\
                &= \frac{(1+\phi)\phi^{n-2}-(1+\psi)\psi^{n-2}}{\sqrt{5}} \\
                &= \frac{\phi^2\phi^{n-2}-\psi^2\psi^{n-2}}{\sqrt{5}} \\
                &= \frac{\phi^n-\psi^n}{\sqrt{5}} \\
                &= f(n)
\end{align*}

In basic cases $f(0)=Fib(0) and f(1)=Fib(1)$. Given $f(n-2)=Fib(n-2)$ and
 $f(n-1)=Fib(n-1)$ there is
 $f(n)=f(n-1)+f(n-2)=Fib(n-1)+Fib(n-2)=Fib(n)$. Therefore, Fib(n)=f(n)
 stands for all non-negative integer n.

Besides, there is $|\frac{\psi^n}{\sqrt{5}}|<\frac{1}{2}$:

\begin{align*}
({\frac{\psi^n}{\sqrt{5}}})^2 &=    \frac{({\frac{1-\sqrt{5}}{2}})^{2n}}{5} \\
                              &=    \frac{({\frac{3-\sqrt{5}}{2}})^{n}}{5} \\
                              &\leq \frac{(\frac{1}{2})^n}{5} \\
                              &\leq \frac{1}{5} \\
                              &<    \frac{1}{4}
\end{align*}

Since $Fib(n)=\frac{\phi^n}{\sqrt{5}}+\frac{\psi^n}{\sqrt{5}}$, $Fib(n)$ is the closest
 integer to $\frac{\phi^n}{\sqrt{5}}$.

% exercise 1.14

\section{}

Since the tree is really large, here only the process of \lstinline{(count-change 4)} is illustrated.

\vspace{5mm}
\begin{tikzpicture}[sibling distance=64pt, level distance=24pt]

\node{\lstinline{count-change 4}}
	child{node{\lstinline{cc 4 5}}
		child{node{\lstinline{cc 4 4}}
			child{node{\lstinline{cc 4 3}}
				child{node{\lstinline{cc 4 2}}
					child{node{\lstinline{cc 4 1}}
						child{node{\lstinline{cc 4 0}}
							child{node{\lstinline{0}}}
						}
						child{node{\lstinline{cc 3 1}}
							child{node{\lstinline{cc 3 0}}
								child{node{\lstinline{0}}}
							}
							child{node{\lstinline{cc 2 1}}
								child{node{\lstinline{cc 2 0}}
									child{node{\lstinline{0}}}
								}
								child{node{\lstinline{cc 1 1}}
									child{node{\lstinline{cc 1 0}}
										child{node{\lstinline{0}}}
									}
									child{node{\lstinline{cc 0 1}}
										child{node{\lstinline{1}}}
									}
								}
							}
						}
					}
					child{node{\lstinline{cc -1 2}}
						child{node{\lstinline{0}}}
					}
				}
				child{node{\lstinline{cc -6 3}}
					child{node{\lstinline{0}}}
				}
			}
			child{node{\lstinline{cc -21 4}}
				child{node{\lstinline{0}}}
			}
		}
		child{node{\lstinline{cc -46 5}}
			child{node{\lstinline{0}}}
		}
	};

\end{tikzpicture}
\vspace{5mm}

The number of steps is $\Theta(5^n)$ and the space is $\Theta(n)$.

% exercise 1.15

\section{}

\paragraph{a.}
Five times.

\paragraph{b.}
The number of steps as well as the space is $\Theta(log(a))$.

\end{document}




