\documentclass[a4paper]{report}

\usepackage{listings}
\usepackage{courier}
\usepackage{titlesec}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{tikz}

\titlespacing{\section}{0pt}{32pt}{16pt}
\titlelabel{Exercise \thesection}

\lstset{basicstyle=\footnotesize\ttfamily, breaklines=true, frame=single, language=Lisp}

\begin{document}

\title{Solutions \\
\large Structure and Interpretation of Computer Programs}
\author{Eric Wen}
\date{Last Modified: April 2017}
\maketitle

\begin{multicols}{2}
  \tableofcontents
\end{multicols}

%
% chapter 1
%

\chapter{Building Abstractions with Procedures}

% exercise 1.1

\section{}

\begin{multicols}{2}
  \begin{itemize}
    \item 10
    \item 12
    \item 8
    \item 3
    \item 6
    \item a (with value 3)
    \item b (with value 4)
    \item 19
    \item \#f (true)
    \item 4
    \item 16
    \item 6
    \item 16
  \end{itemize}
\end{multicols}

% exercise 1.2

\section{}

\begin{lstlisting}
(/ (+ 5
      4
      (- 2
         (- 3
            (+ 6
               (/ 4 3)))))
   (* 3
      (- 6 2)
      (- 2 7)))
\end{lstlisting}

% exercise 1.3

\section{}

\begin{lstlisting}
(define (min2 a b)
  (if (< a b)
      a
      b))
(define (min3 a b c)
  (min2 a
        (min2 b c)))
(define (square x)
  (* x x))
(define (f a b c)
  (- (+ (square a)
        (square b)
        (square c))
     (square (min3 a b c))))
\end{lstlisting}

% exercise 1.4

\section{}

If b is positive, evaluate \lstinline{(- a b)} (i.e. a - b), otherwise evaluate \lstinline{(+ a b)} (i.e. a + b).

% exercise 1.5

\section{}

\subsection*{Applicative-order Evaluation}

\begin{lstlisting}
(test 0 (p)) ->
(test 0 (p)) ->
(test 0 (p)) ->
(test 0 (p)) ->
......
\end{lstlisting}

In applicative-order evaluation, a procedure is not reduced until all its arguments are evaluated. Thus the expression \lstinline{(p)} is constantly being expanded into itself over and over again while the procedure \lstinline{test} can never get the chance to be reduced.

\subsection*{Normal-order Evaluation}

\begin{lstlisting}
(test 0 (p)) ->
(if (= 0 0) 0 (p)) ->
0
\end{lstlisting}

In normal-order evaluation, a procedure's arguments are not evaluated until they're needed, which means the procedure is always reduced until it only involves primitive operators before its arguments are evaluated. Due to the special evaluation rule of \lstinline{if} where the alternative expression is not evaluated if the predicate expression is evaluated to be true, the function \lstinline{test} returns 0 before \lstinline{(p)} gets the chance to be evaluated.

% exercise 1.6

\section{}

The program will run infinitely until it runs out of memory.

\lstinline{if} has a special evaluation rule where either the consequent or the alternative expression is evaluated depending on the value of the predicate expression. In the implementation of Newton's Method, the procedure should immediately return current value when the value is good enough, and here's where \lstinline{if} comes in: if the requirement is met, the recursive call is not made.
 
But the program using \lstinline{new-if} always evaluates both the consequent and the alternative expression, causing the procedure to recursively call itself infinitely.

% exercise 1.7

\section{}

For very small numbers, the threshold value 0.001 is too large to tell if current estimation is close enough to real value.

\lstinline{(sqrt 0.00000001)} returns 0.03125, while 0.0001 is the real value.

For very large numbers, the precision is lost during calculation, hence the estimation can never get close enough ('close' defined by the threshold value 0.001) to real value.

\lstinline{(sqrt (expt 10 150))} fails to return within a reasonable amount of time.

Code after improvement:

\begin{lstlisting}
(define (sqrtIter guess lastGuess x)
  (if (goodEnough guess lastGuess)
      guess
      (sqrtIter (improve guess x)
                guess
                x)))
(define (improve guess x)
  (average guess
           (/ x guess)))
(define (average x y)
  (/ (+ x y)
     2))
(define (goodEnough guess lastGuess)
  (< (/ (abs (- guess lastGuess))
        lastGuess)
     0.001))
(define (sqrt x)
  (sqrtIter 1.0 x x))
\end{lstlisting}

After improvement, function calls mentioned above return 1e-4 and 1e75 respectively.

% exercise 1.8

\section{}

\begin{lstlisting}
(define (cbrtIter guess lastGuess x)
  (if (goodEnough guess lastGuess)
      guess
      (cbrtIter (improve guess x)
                guess
                x)))
(define (improve guess x)
  (/ (+ (/ x
           (* guess guess))
        (* guess 2))
     3))
(define (goodEnough guess lastGuess)
  (< (/ (abs (- guess lastGuess))
        lastGuess)
     0.001))
(define (cbrt x)
  (cbrtIter 1.0 x x))
\end{lstlisting}

% exercise 1.9

\section{}

\begin{lstlisting}
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
\end{lstlisting}

The process is recursive.

\begin{lstlisting}
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
\end{lstlisting}

The process is iterative.

% exercise 1.10

\section{}

\begin{lstlisting}
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
...
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (* 2 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
...
(A 0 512)
(* 2 512)
(1024
\end{lstlisting}

\begin{lstlisting}
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 (* 2 2)))
(A 1 (A 1 4))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
(A 1 (A 0 (A 0 (A 0 2))))
(A 1 (A 0 (A 0 (* 2 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 (* 2 4)))
(A 1 (A 0 8))
(A 1 (* 2 8))
(A 1 16)
...
65536
\end{lstlisting}

\begin{lstlisting}
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1)))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1)))
(A 2 (A 0 2))
(A 2 (* 2 2))
(A 2 4)
...
65536
\end{lstlisting}

\begin{itemize}
\item \lstinline{(f n)} equals \lstinline{(A 0 n)} equals \lstinline{(* 2 n)} which computes 2n for positive n.
\item \lstinline{(g n)} equals \lstinline{(A 1 n)} equals \lstinline{(A 0 (A 1 (- n 1)))} equals \lstinline{(* 2 (A 1 (- n 1)))} (which, though, is not the way it's evaluated). In the basic case \lstinline{(A 1 1)} returns 2, thus \lstinline{(g n)} computes $2^n$ for positive n.
\item \lstinline{(h n)} equals \lstinline{(A 2 n)} equals \lstinline{(A 1 (A 2 (- n 1)))} equals \lstinline{(expt 2 (A 2 (- n 1)))} (which, though, is not the way it's evaluated). In the basic case \lstinline{(A 2 1)} returns 2. Informally, \lstinline{(h n)} computes $2^{2^{2^{...}}}$ where the number of 2 is n. The concise definition can be given recursively as follows: \lstinline{(h 1)} returns 2 for 1, and returns \lstinline{(expt 2 (h (- n 1)))} for n larger than 1.
\end{itemize}

% exercise 1.11

\section{}

Recursive version:

\begin{lstlisting}
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1))
         (* 2 (f (- n 2)))
         (* 3 (f (- n 3))))))
\end{lstlisting}

Iterative version:

\begin{lstlisting}
(define (f n)
  (define (fIter n curr a b c)
    (if (= curr n)
        a
        (fIter n (+ 1 curr) (+ a (* 2 b) (* 3 c)) a b)))
  (if (< n 3)
      n
      (fIter n 2 2 1 0)))
\end{lstlisting}

% exercise 1.12

\section{}

\begin{lstlisting}
(define (pascal line row)
  (if (or (= row 1)
          (= row line))
      1
      (+ (pascal (- line 1) (- row 1))
         (pascal (- line 1) row))))
\end{lstlisting}

% exercise 1.13

\section{}

Let $\phi = \frac{1 + \sqrt{5}}{2}$, $\psi = \frac{1 - \sqrt{5}}{2}$.

Let $f(n) = \frac{\phi ^ n - \psi ^ n}{\sqrt{5}}$. Then there are $f(0) = 0$, $f(1) = 1$.

For any n larger than 1, consider $f(n - 1)$ and $f(n - 2)$:

\begin{align*}
f(n-1) + f(n-2) &= \frac{\phi^{n-1} + \phi^{n-2}-(\psi^{n-1}+\psi^{n-2})}{\sqrt{5}} \\
                &= \frac{(1+\phi)\phi^{n-2}-(1+\psi)\psi^{n-2}}{\sqrt{5}} \\
                &= \frac{\phi^2\phi^{n-2}-\psi^2\psi^{n-2}}{\sqrt{5}} \\
                &= \frac{\phi^n-\psi^n}{\sqrt{5}} \\
                &= f(n)
\end{align*}

In basic cases $f(0)=Fib(0) and f(1)=Fib(1)$. Given $f(n-2)=Fib(n-2)$ and
 $f(n-1)=Fib(n-1)$ there is
 $f(n)=f(n-1)+f(n-2)=Fib(n-1)+Fib(n-2)=Fib(n)$. Therefore, Fib(n)=f(n)
 stands for all non-negative integer n.

Besides, there is $|\frac{\psi^n}{\sqrt{5}}|<\frac{1}{2}$:

\begin{align*}
({\frac{\psi^n}{\sqrt{5}}})^2 &=    \frac{({\frac{1-\sqrt{5}}{2}})^{2n}}{5} \\
                              &=    \frac{({\frac{3-\sqrt{5}}{2}})^{n}}{5} \\
                              &\leq \frac{(\frac{1}{2})^n}{5} \\
                              &\leq \frac{1}{5} \\
                              &<    \frac{1}{4}
\end{align*}

Since $Fib(n)=\frac{\phi^n}{\sqrt{5}}+\frac{\psi^n}{\sqrt{5}}$, $Fib(n)$ is the closest
 integer to $\frac{\phi^n}{\sqrt{5}}$.

% exercise 1.14

\section{}

Since the tree is really large, here only the process of \lstinline{(count-change 4)} is illustrated.

\vspace{5mm}
\begin{tikzpicture}[sibling distance=64pt, level distance=24pt]

\node{\lstinline{count-change 4}}
  child{node{\lstinline{cc 4 5}}
    child{node{\lstinline{cc 4 4}}
      child{node{\lstinline{cc 4 3}}
        child{node{\lstinline{cc 4 2}}
          child{node{\lstinline{cc 4 1}}
            child{node{\lstinline{cc 4 0}}
              child{node{\lstinline{0}}}
            }
            child{node{\lstinline{cc 3 1}}
              child{node{\lstinline{cc 3 0}}
                child{node{\lstinline{0}}}
              }
              child{node{\lstinline{cc 2 1}}
                child{node{\lstinline{cc 2 0}}
                  child{node{\lstinline{0}}}
                }
                child{node{\lstinline{cc 1 1}}
                  child{node{\lstinline{cc 1 0}}
                    child{node{\lstinline{0}}}
                  }
                  child{node{\lstinline{cc 0 1}}
                    child{node{\lstinline{1}}}
                  }
                }
              }
            }
          }
          child{node{\lstinline{cc -1 2}}
            child{node{\lstinline{0}}}
          }
        }
        child{node{\lstinline{cc -6 3}}
          child{node{\lstinline{0}}}
        }
      }
      child{node{\lstinline{cc -21 4}}
        child{node{\lstinline{0}}}
      }
    }
    child{node{\lstinline{cc -46 5}}
      child{node{\lstinline{0}}}
    }
  };

\end{tikzpicture}
\vspace{5mm}

The number of steps is $\Theta(5^n)$ and the space is $\Theta(n)$.

% exercise 1.15

\section{}

\paragraph{a.}
Five times.

\paragraph{b.}
The number of steps as well as the space is $\Theta(log(a))$.

% exercise 1.16

\section{}

\begin{lstlisting}
(define (fast-exp b n)
  (fast-exp-iter b n 1))
(define (fast-exp-iter b n product)
  (cond ((= n 0) product)
        ((even n) (fast-exp-iter (* b b) (/ n 2) product))
        (else (fast-exp-iter b (- n 1) (* product b)))))
(define (even n)
  (= (remainder n 2) 0))
\end{lstlisting}

% exercise 1.17

\section{}

\begin{lstlisting}
(define (fast-mul a b)
  (if (> a b)
      (fast-mul-recur b a)
      (fast-mul-recur a b)))
(define (fast-mul-recur a b)
  (cond ((= a 0) 0)
        ((= a 1) b)
        ((even a) (fast-mul-recur (halve a) (double b)))
        (else (+ b (fast-mul-recur (- a 1) b)))))
(define (even n)
  (= (remainder n 2) 0))
(define (double n)
  (* n 2))
(define (halve n)
  (/ n 2))
\end{lstlisting}

% exercise 1.18

\section{}

\begin{lstlisting}
(define (fast-mul a b)
  (if (> a b)
      (fast-mul-iter b a 0)
      (fast-mul-iter a b 0)))
(define (fast-mul-iter a b sum)
  (cond ((= a 0) sum)
        ((even a) (fast-mul-iter (halve a) (double b) sum))
        (else (fast-mul-iter (- a 1) b (+ b sum)))))
(define (even n)
  (= (remainder n 2) 0))
(define (double n)
  (* n 2))
(define (halve n)
  (/ n 2))
\end{lstlisting}

% exercise 1.19

\section{}

\begin{lstlisting}
(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even count) (fib-iter a
                                b
                                (+ (* p p) (* q q))
                                (+ (* q q) (* 2 (* p q)))
                                (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
(define (even n)
  (= (remainder n 2) 0))
\end{lstlisting}

% exercise 1.20

\section{}

\subsection*{Normal-order Evaluation}

\begin{lstlisting}
(gcd 206 40) ->

(if (= 40 0) 206 (gcd 40 (remainder 206 40))) ->

(gcd 40 (remainder 206 40)) ->

(if (= (remainder 206 40) 0) 40 (gcd (remainder 206 40) (remainder 40 (remainder 206 40)))) ->

(gcd (remainder 206 40) (remainder 40 (remainder 206 40))) ->

(if (= (remainder 40 (remainder 206 40)) 0) (remainder 206 40) (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))) ->

(gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))) ->

......
\end{lstlisting}

18 \lstinline{remainder} operations are actually performed.

\subsection*{Applicative-order Evaluation}

\begin{lstlisting}
(gcd 206 40) ->
(if (= 40 0) 206 (gcd 40 (remainder 206 40))) ->
(gcd 40 6) ->
(if (= 6 0) 40 (gcd 6 (remainder 40 6))) ->
(gcd 6 4) ->
(if (= 4 0) 6 (gcd 4 (remainder 6 4))) ->
(gcd 4 2) ->
(if (= 2 0) 4 (gcd 2 (remainder 4 2))) ->
(gcd 2 0) ->
(if (= 0 0) 2 (gcd 0 (remainder 2 0))) ->
2
\end{lstlisting}

4 \lstinline{remainder} operations are actually performed.

% exercise 1.21

\section{}

The smallest divisor of 199 is 199.

The smallest divisor of 1999 is 1999.

The smallest divisor of 19999 is 7.

% exercise 1.22

\section{}

\begin{lstlisting}
(define (search-for-primes n count)
  (if (> count 0)
      (if (timed-prime-test n)
          (search-for-primes (+ n 2) (- count 1))
          (search-for-primes (+ n 2) count))))
(define (timed-prime-test n)
  (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (let ((result (prime? n)))
       (if result
           (report-prime n (- (runtime) start-time)))
       result))
(define (report-prime n elapsed-time)
  (newline)
  (display n)
  (display " *** ")
  (display elapsed-time))
(define (prime? n)
  (= n (smallest-divisor n)))
(define (smallest-divisor n)
  (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b)
  (= (remainder b a) 0))
\end{lstlisting}

Since computers have become much faster than before so that
 times required to test the primality of such small numbers
 can hardly be distinguished from each other. To get observable
 results, bigger numbers such as 1e10 are needed.

Code used for testing:

\begin{lstlisting}
(search-for-primes (+ 1 1e10) 3)
(search-for-primes (+ 1 1e11) 3)
(search-for-primes (+ 1 1e12) 3)
\end{lstlisting}

Output:

\begin{lstlisting}
10000000019. *** .21999999999999975
10000000033. *** .20999999999999996
10000000061. *** .20999999999999996
100000000003. *** .6999999999999993
100000000019. *** .6800000000000015
100000000057. *** .6799999999999997
1000000000039. *** 2.120000000000001
1000000000061. *** 2.1700000000000017
1000000000063. *** 2.169999999999998
\end{lstlisting}

As the number scales up by 10, the primality
 test takes roughly 3 times as before, which is
 quite close to $\sqrt{10}$

% exercise 1.23

\section{}

Code after modification:

\begin{lstlisting}
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))
(define (next divisor)
  (if (= divisor 2) 3 (+ divisor 2)))
\end{lstlisting}

The code used for testing:

\begin{lstlisting}
(search-for-primes (+ 1 1e10) 3)
(search-for-primes (+ 1 1e11) 3)
(search-for-primes (+ 1 1e12) 3)
\end{lstlisting}

Output:

\begin{lstlisting}
10000000019. *** .12000000000000002
10000000033. *** .13
10000000061. *** .12
100000000003. *** .41000000000000003
100000000019. *** .3900000000000001
100000000057. *** .3999999999999999
1000000000039. *** 1.23
1000000000061. *** 1.2299999999999995
1000000000063. *** 1.3499999999999996
\end{lstlisting}

It's roughly 1.75 times as faster. The number of test steps
 did halve but the extra test in \lstinline{next} procedure
 takes a small amount of time.

% exercise 1.24

\section{}

Code used for testing (given that \lstinline{n=100} in \lstinline{fast-prime?}):

\begin{lstlisting}
(search-for-primes 10000000001 3)
(search-for-primes 100000000000001 3)
(search-for-primes 1000000000000000001 3)
\end{lstlisting}

Output:

\begin{lstlisting}
10000000019 *** 1.0000000000000009e-2
10000000033 *** 1.0000000000000009e-2
10000000061 *** 1.0000000000000009e-2
100000000000031 *** 1.0000000000000009e-2
100000000000067 *** 1.0000000000000009e-2
100000000000097 *** 1.0000000000000009e-2
1000000000000000003 *** 1.0000000000000009e-2
1000000000000000009 *** 1.0000000000000009e-2
1000000000000000031 *** 1.0000000000000009e-2
\end{lstlisting}

As the number scales up by 10000, the time required
 goes up roughly by a constant.

% exercise 1.25

\section{}

She's not correct.

For very large numbers, overflow may happen in \lstinline{fast-exp}, leading to undefined mistake.
 While in current implementation of \lstinline{expmod}, large numbers whose exponential part is
 large are broken into smaller ones, and replaced by their remainders which is much smaller, preventing
 overflow from happening.

% exercise 1.26

\section{}

In current implementation of \lstinline{expmod}, each time the procedure gets called, the scale of the
 problem roughly get halved. Let $T(n)$ be the time required to compute $a^n \mod m$. Then we have

$$
T(n) = T(\frac{n}{2}) + C
$$

where $C$ is a constant amount of time. Therefore it's a $\Theta(\log n)$ process.

In Louis's code, each time the procedure gets called, the scale of the problem remains the same. Although
 both subproblems (i.e. recursive calls) have half the scale, the duplicate calls add them up.
 This can be shown with

$$
T(n) = 2T(\frac{n}{2}) + C
$$

making it a $\Theta(n)$ process.

% exercise 1.27

\section{}

Code:

\begin{lstlisting}
(define (even? exp)
  (= (remainder exp 2) 0))
(define (expmod base exp n)
  (cond ((= exp 0) 1)
        ((even? exp)
          (remainder (square (expmod base (/ exp 2) n)) 
                     n))
        (else
          (remainder (* base (expmod base (- exp 1) n))
                     n))))
(define (carmichael-test n)
  (carmichael-test-iter 2 n))
(define (carmichael-test-iter a n)
  (cond ((= a n) true)
        ((= (expmod a n n) a) (carmichael-test-iter (+ a 1) n))
        (else false)))
\end{lstlisting}

Code used for testing:

\begin{lstlisting}
(carmichael-test 561)
(carmichael-test 1105)
(carmichael-test 1729)
(carmichael-test 2465)
(carmichael-test 2821)
(carmichael-test 6601)
\end{lstlisting}

A Carmichael number should pass every Fermat test, while
 itself is actually not a prime. All procedure calls above
 return true, while none of the numbers are prime, shown
 as follows:

\begin{align*}
561 &= 3 \times 11 \times 17 \\
1105 &= 5 \times 13 \times 17 \\
1729 &= 7 \times 13 \times 19 \\
2465 &= 5 \times 17 \times 29 \\
2821 &= 7 \times 13 \times 31 \\
6601 &= 7 \times 23 \times 41
\end{align*}

% exercise 1.28

\section{}

Code:

\begin{lstlisting}
(define (even? exp)
  (= (remainder exp 2) 0))
(define (check-result result n)
  (let ((remain (remainder (square result) n)))
    (if (and (not (= result 1))
             (not (= result (- n 1)))
             (= remain 1))
        0
        remain)))
(define (expmod base exp n)
  (cond ((= exp 0) 1)
        ((even? exp)
          (check-result (expmod base (/ exp 2) n) n))
        (else
          (remainder (* base (expmod base (- exp 1) n))
                     n))))
(define (miller-rabin-test n)
  (define (try-it a)
    (= (expmod a (- n 1) n) 1))
  (try-it (+ 1 (random (- n 1)))))
(define (fast-prime? n times)  (cond ((= times 0) true)        ((miller-rabin-test n) (fast-prime? n (- times 1)))        (else false)))
(define (prime? n)
  (fast-prime? n 100))
\end{lstlisting}

Code used for testing:

\begin{lstlisting}
;; some prime numbers
;; outputs are supposed to be #t
(prime? 2)
(prime? 3)
(prime? 5)
(prime? 7)
(prime? 11)
(prime? 13)
(prime? 17)
(prime? 19)

;; some non-prime numbers
;; outputs are supposed to be #f
(prime? 4)
(prime? 6)
(prime? 8)
(prime? 9)
(prime? 10)
(prime? 12)
(prime? 14)
(prime? 15)

;; some Carmichael numbers
;; outputs are supposed to be #f
(prime? 561)
(prime? 1105)
(prime? 1729)
(prime? 2465)
(prime? 2821)
(prime? 6601)
\end{lstlisting}

% exercise 1.29

\section{}

Code:

\begin{lstlisting}
(define (sum term next a b result i)
  (if (> a b)
      result
      (sum term next (next a) b (+ result (term a i)) (+ i 1))))
(define (simpson f a b n)
  (let ((h (/ (- b a) n)))
    (define (term a i)
      (define (even? i)
        (= (remainder i 2) 0))
      (if (even? i)
          (* (f a) (/ (* 2.0 h) 3))
          (* (f a) (/ (* 4.0 h) 3))))
    (define (next a)
      (+ a h))
    (- (sum term next a b 0 0)
       (* (/ h 3) (+ (f a) (f b))))))
(define (cube x) (* x x x))
\end{lstlisting}

Code used for testing:

\begin{lstlisting}
(simpson cube 0 1 10)
(simpson cube 0 1 100)
(simpson cube 0 1 1000)
(simpson cube 0 1 10000)
(simpson cube 0 1 100000)
\end{lstlisting}

Output:

\begin{lstlisting}
.25
.25
.2499999999999998
.25000000000000017
.24999999999999864
\end{lstlisting}

The results are far more precise than
 those of the \lstinline{integral}
 procedure.

% exercise 1.30

\section{}

Code:

\begin{lstlisting}
(define (sum term next a b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ result (term a)))))
  (iter a 0))
\end{lstlisting}

% exercise 1.31

\section{}

\subsection*{a.}

Code:

\begin{lstlisting}
(define (product term next a b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* result (term a)))))
  (iter a 1))
(define (factorial n)
  (define (self n) n)
  (define (inc n) (+ 1 n))
  (product self inc 1 n))
(define (pi n)
  (define (square n) (* n n))
  (define (double-inc n) (+ 2 n))
  (* 4 (* (+ n 1.0)
          (/ (product square double-inc 2 (* 2 n))
             (product square double-inc 3 (+ 1 (* 2 n)))))))
\end{lstlisting}

Notice that \lstinline{n} shouldn't be
 too large, or overflow may happen in
 \lstinline{product} procedure.

\subsection*{b.}

Recursive version of \lstinline{product}:

\begin{lstlisting}
(define (product term next a b)
  (define (iter a)
    (if (> a b)
        1
        (* (term a) (iter (next a)))))
  (iter a))
\end{lstlisting}

\end{document}




